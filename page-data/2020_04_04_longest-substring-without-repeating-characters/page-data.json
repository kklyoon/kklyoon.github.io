{"componentChunkName":"component---src-templates-blog-post-index-js","path":"/2020_04_04_longest-substring-without-repeating-characters/","result":{"data":{"site":{"siteMetadata":{"title":"My training box","author":"kklyoon"}},"markdownRemark":{"id":"590e58c9-aa16-523f-a0ea-cd8c8645284c","html":"<p>원문 : <a href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters/\">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a></p>\n<p>Given a string, find the length of the longest substring without repeating characters.</p>\n<p><strong>Example 1:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\">\n      <pre class=\"language-text\"><code class=\"language-text\">Input: &quot;abcabcbb&quot;\nOutput: 3 \n\nExplanation: The answer is &quot;abc&quot;, with the length of 3. </code></pre>\n      </div>\n<p><strong>Example 2:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\">\n      <pre class=\"language-text\"><code class=\"language-text\">Input: &quot;bbbbb&quot;\nOutput: 1\nExplanation: The answer is &quot;b&quot;, with the length of 1.</code></pre>\n      </div>\n<p><strong>Example 3:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\">\n      <pre class=\"language-text\"><code class=\"language-text\">Input: &quot;pwwkew&quot;\nOutput: 3\nExplanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</code></pre>\n      </div>\n<p>The idea is simple, I use last[] to record the last position of characters. beginPos and lastPos record the range of the current sub string.</p>\n<p>For a character, if the last position of a character is before the beginPos, we increase the sub string, otherwise we start from the last position + 1.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\">\n      <pre class=\"language-c++\"><code class=\"language-c++\">class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int last[256];\n        int maxSize = 0;        \n        int beginPos = 0;\n        fill_n(last, 256, -1);\n        for (int lastPos = 0; lastPos &lt; s.size(); lastPos++) {\n           if (last[s[lastPos]] &lt; beginPos) {   \n               // substring 길이 증가\n               maxSize = max(maxSize, lastPos-beginPos+1);\n           } else {     // \n               beginPos = last[s[lastPos]] + 1;     //substring 다시 시작\n           }\n           last[s[lastPos]] = lastPos;  // s[lastPos] 의 위치 저장\n        }\n        \n        return maxSize;\n    }\n};</code></pre>\n      </div>\n<p>각 char 의 위치를 저장하면서 substring 의 길이를 업데이트 해준 뒤 가장 긴 substring 길이를 저장한다. <br>\nlast[s[lastPos]] : s[lastPos] 문자가 있는 마지막 위치, 초기값 -1 <br>\nbeginPos : substring 시작지점  <br>\ns 길이만큼 반복하며 last[] 에 해당 char 가 이전에 어느 위치에 있는지 검사\nif 전에 위치가 substring 시작위치보다 앞에 있으면 substring 길이 증가, maxSize 와 비교해서 큰 값 저장\nelse 전에 위치가 substring 시작 위치와 같거나 뒤에 있으면 substring 끝 시작 위치 다시 저장</p>\n<p><code class=\"language-text\">다른코드</code></p>\n<div class=\"gatsby-highlight\" data-language=\"c++\">\n      <pre class=\"language-c++\"><code class=\"language-c++\">int lengthOfLongestSubstring(string s) {\n        vector&lt;int&gt; dict(256, -1);\n        int maxLen = 0, start = -1;\n        for (int i = 0; i != s.length(); i++) {\n            if (dict[s[i]] &gt; start)\n                start = dict[s[i]];\n            dict[s[i]] = i;\n            maxLen = max(maxLen, i - start);\n        }\n        return maxLen;\n    }</code></pre>\n      </div>","excerpt":"원문 : https://leetcode.com/problems/longest-substring-without-repeating-characters/ Given a string, find the length of the longest substring…","frontmatter":{"title":"[Algorithm][LeetCode] find the length of the longest substring without repeating characters","date":"2020-04-04","tags":["알고리즘","algorithm"],"keywords":["My training box"]}}},"pageContext":{"slug":"/2020_04_04_longest-substring-without-repeating-characters/","previous":{"fields":{"slug":"/2020_04_03_scope_function/"},"frontmatter":{"title":"[Kotlin][번역 및 요약] Scope Function","tags":["Kotlin","코틀린","ScopeFunction","번역","run","with","let","apply","also"],"published":true}},"next":{"fields":{"slug":"/2020_04_06_between-two-sets/"},"frontmatter":{"title":"[Algorithm][hackerrank] Between Two Sets","tags":["알고리즘","algorithm","hackerrank"],"published":true}}}},"staticQueryHashes":["3649515864"]}