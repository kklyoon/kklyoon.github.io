{"componentChunkName":"component---src-pages-search-js","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n[원문](https://www.careercup.com/question?id=15422849)\n\n```\nPots of gold game: Two players A & B. There are pots of gold arranged in a line, each containing some gold coins (the players can see how many coins are there in each gold pot - perfect information). They get alternating turns in which the player can pick a pot from one of the ends of the line. The winner is the player which has a higher number of coins at the end. The objective is to \"maximize\" the number of coins collected by A, assuming B also plays optimally. A starts the game. \n\nThe idea is to find an optimal strategy that makes A win knowing that B is playing optimally as well. How would you do that? \n\nAt the end I was asked to code this strategy!\n```\n\n단순히 큰 값 두개씩 고른다고 생각하면 안되는 문제\n\nA와 B 모두 자신에게 가장 유리한 값을 고른다는 조건이 관건이다.\n\n- A가 왼쪽을 고른경우 + min(B가 다음 왼쪽을 고른경우, B가 오른쪽을 고른경우)\n- A가 오른쪽을 고른것 + min(B가 왼쪽을 고른경우, B가 다음 오른쪽을 고른경우)\n\n을 각각 구한 뒤 큰값을 고르면 된다.\n\n```kotlin\nimport kotlin.math.*\n\n\nfun sol(arr: IntArray, start: Int, end: Int): Int{\n    if(start>end) return 0\n\n    val l = arr[start] + min(sol(arr, start+2, end), sol(arr, start+1, end-1))\n    val r = arr[end] + min(sol(arr, start+1, end - 1), sol(arr, start, end-2))\n    return max(l,r)\n}\n\n```\n\nDP문제는 점화식을 어떻게 구하는가가 관건인듯하다.\n","fields":{"slug":"/2020-11-16_Pots_of_gold_game/"},"frontmatter":{"title":"[Algorithm] Pots of gold game","published":true}}},{"node":{"rawMarkdownBody":"\n\n원문 : https://www.techyourchance.com/android-developer-skills/\n\n\n많은 안드로이드 개발자들이 \"좋은 안드로이드 개발자가 되기위해 뭘 알아야 하죠?\" 라고 물어본다. 그걸 다르게 표현할 수 있겠지만 결국 개발자들이 배워야할 유용한 기술 리스트를 찾는다는 사실로 귀결된다. \n\n일리가 있는 질문이다. 안드로이드 개발은 거대하고 역동적인 생태계인데, 몇 주동안은 특정 도구의 사용법이나 개념을 익힐 수 있는데 이는 중요하지 않거나 거의 사용되지 않는 것들을 알아가는 것일 뿐이다. 이 글에서는 안드로이드 개발자들이 갖춰야할 기술 리스트를 공유하여 개발자들이 중요한 것에 집중하는데 도움이 되고자 한다.\n\n### 경력 수준\n\n분명히, 경력이 쌓이면 더 많은 지식을 얻을거라 기대한다. 그러나 몇몇 개념이나 아이디어들은 너무 앞서나가서 많은 경험이 쌓이기 전에 더 많은 지식을 요구한다. 그래서 전문적인 안드로이드 개발자가 알아야할 모든 기술 리스트를 언급할 수는 없다. 그 대신 독자의 경력에 따라 추천하는 기술셋이 있다. 하지만 이것이 정확한 척도는 아님을 명심하고 일반적인 사례라는 것을 명심했으면 한다.\n\n### 간단한 앱도 만드는 방법을 모를 때\n\n만약 안드로이드 개발자가 되기로 결심했고 아직 간단한 앱도 만들어보지 않았다면 이 글을 읽는게 이를 수도 있다. 이 글은 개발자나 어느정도 경험이 있는 사람들을 위한 것이다.\n\n그러나 이 글을 읽는 사람이 아무것도 얻지 못하는 것은 아니다. 이 포스팅에서는 짧은 시간안에 안드로이드 개발자가 되는 단계를 요약할 것인데 실전 경험을 쌓고 다시 이 글을 읽으면 꽤 도움이 될 것이다.\n\n이 포스팅의 끝부분에서는 독자가 이미 플레이스토어에 앱을 배포했고 소스코드는 GitHub에 있다고 가정할 것이다.\n\n\n### 2년차 이하 경력의 안드로이드 개발자\n\n안드로이드는 가파른 학습곡선을 가진 복잡한 프레임워크이다. 복잡성의 일부는 네이티브 앱 개발에 필수적인 요소이지만 나머지는 안드로이드 특성에 따른 우연한 복잡성이라고 할 수 있다.\n\n안드로이드 개발자의 세계의 커리어를 시작할 때, 궁극적인 목표는 동작하는 소프트웨어를 만드는걸 떠나서 안드로이드 프레임워크를 배우는 것이다. 언어, 아키텍쳐, 최신 라이브러리, 트렌드 같은건 잊어버려라. 대신, 핵심 개념에 집중하고 깊이있게 탐구하자\n\n정확히는 다음 주제에 대해 집중할 것을 권한다.\n\n__Android Memory Management and Process Death__\n\n안드로이드 개발의 가장 복잡한 측면 중 하나가 메모리가 부족할 때 얼마나 안정적이고 알맞게 동작하게 만드는 것이다. 요약하자면: 앱 프로세스는 다른 앱으로 전환될 때 종료될 수 있다. 하지만 사용자는 다시 앱으로 돌아왔을 때 프로세스가 종료되지 않은 화면을 기대하게 된다.\n\n메모리 관리에 대한 자세한 내용은 여기서 언급하지 않겠다. [이 글](https://www.techyourchance.com/android-memory-management-process-death/)에서 자세히 설명해놓았다. \n\n__Lifecycles__\n\n필자가 만약 안드로이드 어플의 복잡성과 버그의 가장 큰 원인에 이름을 붙인다면. 난 기꺼이 `lifecycles`라고 외칠 것이다. (얼굴을 감싸고 울부짖으며...)\n\nApplication, Activity, Fragment, Service, BroadcastReceiver, ContentProvider 그리고 아마도 안드로이드의 핵심 컴포넌트들까지 각자의 복잡성과 lifecycle을 가지고 있다. 거기에서 끝나지 않고 구글은 계속 각자의 복잡성과 lifecycle을 가지고 있는 새로운 라이브러리와 프레임워크를 출시한다. Loader, ViewModel and LiveData 같은 것들 말이다.\n\nlifecycles 에 관한 한가지 흥미로운 사실은 `lifecycle` 이라는 단어의 정의를 본적이 없다는 것이다. 항상 사용하고 있지만 이것의 정확한 의미는 무엇일까? 지금까지 얘기한 것으로 lifecycle 에 관한 직관적인 이미지를 떠올릴 수도 있다. 필자는 lifecycle에 대해 많이 생각도 해보고 써보기도 했으니 이 용어를 한번 정의해보고자 한다.\n\n컴포넌트의 Lifecycle 은 Final State Machine에 대한 추상화이다. 여기서 추상화라는 말의 뜻은 state machine 의 상태와 그것들이 전환되는 조건이 미리 정의되었다는 의미이다. 하지만 완전히 설명하기엔 부족하다. 부족한 부분은 \"lifecycle callback\"이라고 부르는 컴포넌트 메서드의 일부를 뜻한다. FSM 자체 외에 특정 lifecycle callback 에서 할 수 있는 암시적 한계와 제약이 있다. 이러한 한계는 문서에 나와있지만 어떤 점은 나와있지 않다. \n\nlifecycle 이 얼마나 복잡해질까? 글쎄, [이 다이어그램](https://github.com/xxv/android-lifecycle)은 Acitivity 와 Fragment 의 lifecycle 을 보여주는데 (심지어 업데이트가 안되어 정확한 것도 아님). 딱봐도 복잡하고 어렵지만 대부분의 안드로이드 개발자가 이걸 다 이해하는건 아니니까 너무 스트레스 받지 말자. 사실 안드로이드를 만든 구글러도 다 이해못한다. 예를들어 구글이 LifecycleOwner 프레임워크를 출시했을 때, Fragment lifecycle의 context에서 심각한 버그를 지적하면서 그 다음 ViewLifecycleOwner를 사용해서 버그를 피해야한다고 발표했었다.\n\n이제, 안드로이드 lifecycle 을 완벽하게 이해할 필요는 없지만, 어느 정도의 디테일은 이해할 필요가 있다. 그렇지 않으면 코드가 엉망이 되고 매우 까다롭고 심각한 버그를 발생시킬 수 있다. 필자는 최대한 실용적인 방법으로 [Activity lifecycle은 여기서](https://www.techyourchance.com/android-activity-lifecycle) [Fragment lifecycle은 여기서](https://www.techyourchance.com/android-fragment-lifecycle/) 설명해보았다. __onStart() 와 onResume()이 뭐가 다른지 확신이 안들면 읽어보기 바란다.__ \n\nlifecycle 에 대한 기본개념이 감이 온다면 [안드로이드 개발자의 7가지 원죄(실제로는 10가지)](https://proandroiddev.com/the-seven-actually-10-cardinal-sins-of-android-development-491d2f64c8e0) 을 읽어보길 바란다. 이러한 \"원죄\"는 대부분의 안드로이드 개발자들이 하는 실수이다. 예상했듯이 lifecycle과 관련된 실수이다.\n\nlifecycle에 대한 질문은 매우 일반적인 면접 질문이다. 정확히 공부해야할 이유가 생겼다.\n\n__Context__\n\n모든 안드로이드 앱은 하나 이상의 Context가 있다.\n\nlifecycle과 마찬가지로 Context는 수 많은 역할을 하기 때문에 무엇인지 설명하기는 어렵다. 따라서 이를 한두 문장으로 설명하기엔 불가능하다. 그렇지만, Context의 역할과 서로다른 Context들의 차이점을 이해하는 것은 중요하다.\n\ncontext는 말그대로 맥락이다. 이 [StackOverflow 쓰레드](https://stackoverflow.com/questions/3572463/what-is-context-on-android)과 [이 글](https://stackoverflow.com/questions/10641144/difference-between-getcontext-getapplicationcontext-getbasecontext-and/42700601#42700601)을 읽어보길 권한다.(채택답변은 스킵하고)\n\n\n__User Interface (UI) Thread Responsiveness__\n\n안드로이드 앱 마다 UI 쓰레드를 가지고 있다. 이 쓰레드는 화면에서 UI를 그리는 역할을 담당하고 있는데 이 쓰레드를 잘못 다루게 되면 앱 반응성에 악영향을 끼치게 된다. 최악의 경우 앱이 멈춰버리게 된다. \n\n따라서 UI 쓰레드에서 이해하고 거기에 따라서 사용해야한다. [이 비디오](https://www.youtube.com/watch?v=UPq1LDxL5_w&feature=youtu.be)에서 UI 쓰레드에 관련된 세부사항과 유의사항을 포함한 멀티 쓰레딩에 대해 설명하고 있다\n\n__Logic Decomposition__\n\n엄밀히 말해서 안드로이드 프레임워크는 \"clean code\" 라고 할 수는 없다. 수천줄의 코드가 있는 소위 갓 클래스가 혼재되어 있고 이것들을 확장시켜 사용해야하는 것을 강요하고 있다. 결과적으로 한번에 많은 일을 하는 클래스를 작성할 수 밖에 없다. 일반적으로 Application, Activity, Fragment, Service 등을 사용할 때 일어나는 일이다. \n\n하지만, 이런 일이 빈번하더라도 이러한 접근은 유지보수나 개발자의 정신건강에 좋은 일은 아니다. 그러니 이 문제를 유념하면서 클래스를 작성할 때 로직을 분리하여 별도의 클래스를 작성하는 것을 계속 고려하는 것이 좋다.\n\n솔직히 말하자면, 신입 개발자들이 이러한 아키택쳐나 디자인패턴 관련된 작업을 할 수 있다고 생각하지 않는다. 로직을 분리하고 캡슐화하여 클래스로 따로 분리하는 작업은 좀더 많은 경력이 필요하다. 하지만 신입개발자가 로직을 분리하는 작업을 잘해낼 수는 없어도 최악의 경우를 피하기 위해 조금씩 시도는 해봐야 한다. (5천라인이 넘는 activity 같은 최악의 경우)\n\n[이 글](https://www.techyourchance.com/android-context-needs-isolation/)에서 설명한대로 Context 관련된 로직을 분리하는 것을 시도해볼 수 있다. \n\n### Android Developers With 2-4 Years of Experience\n\n어느 정도 경력이 있는 개발자. 안드로이드 프레임워크에 대해 잘 이해하고 있어야 하고 학습과 검색이 좀 필요하더라도 특별한 기능이 아니라면 일정 기한안에 구현할 수 있어야 한다. 그 다음엔 뭘 해야할까?\n\n이제 안드로이드 프레임워크에 익숙할 것이다. 이제 고수준의 스킬을 익힐 차례이다. 이러한 스킬들은 안드로이드 개발에 국한되지 않은 일반적인 개발 스킬들이다. 다음과 같은 주제를 참고해보자.\n\n\n__Dependency Injection__\n\n의존성 주입(DI)은 Separation of Concerns principle(관심사 분리 원칙)에 따른 아키텍쳐 패턴이다. DI는 목적은 어플리케이션에서 두 가지의 주요 관심사를 분리하는 것이다. 하나는 어플리케이션의 핵심 기능 다른 하나는 핵심 기능을 구현하는 구성 요소간의 상호연결\n\n어떤 관점에서는 DI 의 구성요소는 개인용 컴퓨터의 구조와 유사하다. DI 기반은 메인보드와 유사하고, CPU, memory, 주변기기 등의 구성요소는 DI의 기능적 구성요소라고 할 수 있다. DI 가 코드베이스에 구성되면 재사용 가능한 컴포넌트를 추가할 수 있다. 예로 들었단 비유를 잘 기억하면 DI의 핵심 컨셉을 잘 이해할 수 있을 것이다.\n\n아쉽게도 DI라는 주제는 분량이 매우 많기 때문에 이글에서는 다루지 않겠다. [이 글](https://www.techyourchance.com/dependency-injection-myths-debunked/)을 읽어보면서 시작하면 좋을 것이다. DI \"신화\"에 대해서 광범위하게 분석한 글이다. \n\n__Decoupling of User Interface Logic__\n\n안드로이드 프레임워크의 아키텍쳐 자체는 UI 로직과 나머지 부분의 결합이 강하다. 신입 개발자들은 여기에 따라 코드를 작성한다. 이러한 결합은 UI를 \"그리는\" 네트워킹, 멀티쓰레딩, 디바이스 제어, 비지니스로직이 들어 있는 거대한 클래스 등을 만들어낸다. \n\n내 경험으로는 이러한 UI 로직의 결합은 안드로이드 앱을 유지보수 문제의 가장 큰 원인이다. 당장이든 나중이든 이러한 방식의 코드는 매우 이해하기 어렵고 작은 수정에도 side effect 를 발생시킨다. \n\nUI 로직 분리는 Model-View-<somthing> 아키텍쳐 패턴의 주요 목적이다. MVC, MVP, MVVM 등등의 아키텍쳐 패턴이 이러한 경우에 해당된다. 나는 이러한 패턴들을 묶어서 MVx 패턴이라고 한다. \n\nMVx 에 대해서 한가지 유념해야할 점은 아키텍쳐가 아니라 아키텍쳐 패턴이라는 점이다. 게다가 [이런 아키텍쳐 패턴은 앱 내부의 프레젠테이션 로직에만 적용된다](https://twitter.com/VasiliyZukanov/status/1206211507551375360). 따라서 MVx를 도입한다고 \"좋은\" 아키텍쳐가 나오지는 않는다. 좋은 아키텍쳐란 그보다 더 많은 노력이 필요하다는 소리다.\n\n__Multithreading__\n\n경력 안드로이드 개발자는 안드로이드의 멀티쓰레딩 개념과 멀티쓰레딩이 앱에 어떻게 영향을 주는지에 대해 알고 있어야 한다. \"나는 AsyncTask/RxJava/Coroutine 등등으로 다루는게 익숙해. 그럼 됐네\"라고 생각할 수도 있지만 내 말의 의미는 그런것이 아니고 멀티쓰레딩 프레임워크를 사용한다는것이 멀티쓰레딩을 이해한다는 것이 아니라는 것이다. \n\n예를 들어, 많은 경력 개발자들은 AsyncTask를 사용하는게 메모리 누수로 이어진다라고 생각한다. 이러한 생각은 AsyncTask 공식문서와 AndroidStudio의 기본 lint 규칙에도 포함되어 있다. 정말 그런가? 아쉽게도 틀렸다. 이 글에서 이 주제에 대해 자세하게 다루지는 않겠다. [이 글](https://www.techyourchance.com/asynctask-deprecated/)에서 자세한 내용을 확인할 수 있다. \n\n내생각에 멀티쓰레딩을 이해하기 위해서는 Thread 클래서 안에서도 동시성 코드를 올바르게 작성해야 한다. 이 목적을 달성하려면 가장 자주 사용하는 멀티쓰레딩 라이브러리의 API를 아는 것만으로는 충분하지 않다. 라이브러리가 좋아도 멀티쓰레딩을 기본을 이해하지 못하면 멀티쓰레딩 관련 버그가 발생할 수 밖에 없다. \n\n안드로이드의 멀티쓰레딩에 대해 공부하려면 [이 비디오](https://www.youtube.com/watch?v=UPq1LDxL5_w&feature=youtu.be)를 참고하자. 모든 경력 개발자가 알아야할 기본 사항에 대한 체계적인 설명이 포함되어 있다. \n\n__Automated Testing__\n\n대부분의 안드로이드 프로젝트들은 여전히 테스트 자동화를 사용하지 않고 있다. 그 중에서 대부분은 QA 담당자가 Appium과 같은 도구를 사용하여 처리한다. 이 업계의 슬픈현실이고 이 문제는 Android의 기원과 Google이 타사 앱의 자동화된 테스트 과정을 오랬동안 무시했다는 사실로 거슬러 올라간다.  \n\n그렇지만, 유닛테스트와 UI 테스트 경험이 있는 개발자들은 매우 수요가 많다. 테스트 자동화되지 않은 회사에 면접을 보더라도 코드를 유닛테스트 할 수 있다고 말하면 보너스 점수를 받을 것이다. 반대로 테스트 자동화를 많이 쓰는 회사에 면접을 본다면 다른 지원자들에 비해 좋은 점수를 받지 못할 것이다. \n\n따라서 필수는 아니지만 경력 개발자라면 테스트 자동화에 대해 공부해 놓는 편이 좋다. 개인적으로 유닛테스트를 선호하고 UI 테스트는 많이 쓰지 않지만 다른 많은 개발자들은 반대이기도 하다. 뭐가 됐든 더 재밌는 쪽을 선택해 실행해보는걸 권한다. \n\n### Android Developers With 4+ Years of Experience\n\n여기까지 왔다면 이른바 \"meta\" 스킬을 익히고 특정 분야를 전문화 시킬 차례다. 아래의 스킬들은 전문적인 개발자들에게 매우 바람직하다. \n\n__Trade-Off Identification__\n\n결정해야할 많은 기술적인 결정이 결국 타협점을 보는 것이라고 때달아야 할 때이다. 어떨때는 결정이 분명하게 즉각적으로 이루어질 수 있지만 항상 그런것은 아니다. 대게 판단의 범위가 클수록 즉시 할 수 있는 결정들 보다 더 추상적이고 더 많은 절충이 필요하다. \n\n이 수준의 경력에 도달하면 적어도 어느 부분에서 타협을 봐야할지 알 수 있게 된다. 모든 문제가 명박하게 선택할 수 있는 척도를 제공하면 좋겠지만 현실은 좀 더 복잡하다. 보통은 타협점을 판단할 수 있다면 다른 개발자나 관리자들과 토론에서 절충안을 제안할 수 있을 것이다. 따라서 대부분의 경우 타협점을 알아볼 수 있는 정도로 충분하다. \n\n이제 내가 얘기했던 \"타협점 알기\" 이라는 말의 의미가 이해가 가는가? 솔직히 말해서 명확하게 정의하기는 어렵지만 내가 들었던 몇가지 예를 들수는 있다.\n\n\"AsyncTask 는 메모리 누수가 발생하기 때문에 RxJava로 바꿔야 한다.\": 위에 언급 했듯이 틀렸다. 이 얘기를 한 사람은 멀티쓰레딩의 개념을 충분히 이해하지 못한 것이다. 그리고 RxJava의 단점에 대한 언급이 없었다. 적어도 프로젝트에 참여하는 모든 개발자들의 러닝커브를 고려하지 못했다.\n\n\"모든 새 코드에 유닛테스트를 적용하여 장기적인 목표범위를 세워 앱의 퀄리티를 올려야한다.\": 이 주장은 몇가지를 전제로 한다. 하나, 지금 당장 유닛테스트를 시작할 수는 없다. 적어도 개발자들은 이 기술에 대한 공부가 필요하다. 또 테스트를 실행할 CI 시스템이 갖춰져있는지 확인이 필요하다. 그리고 유닛 테스트 할 수 없는 부분이 분명 존재하기 때문에 모든 코드에 적용할 수는 없다. 둘째, 장기적인 목표범위를 이룬다고 저절로 퀄리티가 좋아지는 것도 아니다. 이 경우 개발자는 유닛테스트에 대한 이해도 없다. 그래서 프로젝트에 유닛테스트를 도입하는거에 대한 많은 절충안에 대해 인지 하지 못했다. \n\n몇가지 예를 더 들수는 있지만 이제 무슨 얘기인지 알 것이다. 중요한 결정을 해야할 때 절충안에 대한 복잡함을 깨닫지 못한다면 경력을 쌓는데 필요한 과정을 다 밟지 않았을 수도 있다. 몇몇의 타협점은 기술적인 문제를 벗어나는 것도 있다. 따라서 결정이 다른 부서에 미치는 영향에 대해서도 생각해봐야 한다. \n\n__Specialization__\n\n뛰어난 개발자들이 다른 개발자와 비교했을 때 어떠한 점이 다른가? 많은 기술을 써본거? 내생각은 아니다. 가장 큰 차이점은 지식의 깊이이다. \n\n뛰어난 개발자가 되려면 하나 이상의 전문분야를 가져야한다. 평균적인 개발자들 보다 깊이 이해하고 있는 분야를 말하는 것이다. 전문 분야의 개발에 대한 최신 정보를 얻으려면 지속적으로 노력해야하므로 새로운 도구나 기술에 놀라지 않아도 된다. 그리고 프로젝트에서 이 전문분야가 사용되지 않더라도 전문 분야와 연관된 장단점을 찾아낼 수 있어야 한다. \n\n전문분야를 갖추는 것은 어렵다. 블로그 포스팅에서 고르는 일이 아니다. 좋은 책을 읽고 좋은 수업을 들어서 갖출 수 있는 것도 아니다. 물론 도움이 될 수는 있지만 전문분야를 갖는 유일한 방법은 적극적으로 참여하고 많은 경험을 쌓는 것이다. \n\n난 물리학자 닐보어가 한말을 좋아한다. \n\n```\n전문가는 좁은 분야에서 발생할 수 있는 모든 실수를 해본 사람이다. \n```\n\n어떤 분야가 전문분야가 될 수 있을까? 글세 어떤 것이든? 전문분야가 되기엔 작은 노력으로 될 수 있는 영역이 거의 없다. 당장 생각나는 것들은\n\n- User interfaces\n- Build systems\n- Offline work\n- Concurrency\n- NDK\n- Continuous Integration\n- Performance\n- Architecture\n- Mentoring\n- Project management\n- Business domain knowledge\n- and many, many more.\n\n언급한 것들은 기술적인 영역을 벗어나는 것들도 있다. 맞다. 독자가 좋아하는 어떤 분야도 고용주에게 가치를 보이는 한 전문분야가 될 수 있다. \n\n좋은 안드로이드 개발자가 되기 위해서는 적어도 2~3가지 영역에서 전문분야가 되어야 한다고 생각한다. 예를들어 나같은 경우 : 아키텍쳐, 유닛 테스트, 동시성, DI 등이다. 레거시 코드 리팩토링이 곧 들어갈 것 같기도 하다. \n\n독자가 4년 이상 경력의 개발자라면 어떠한 전문 분야가 있다고 할 수 있는가?\n\n### Conclusion\n\n자 여기까지 전문 안드로이드 개발자로 익혀야할 기술 리스트 였다. \n\n흥미로운 사실은 이 포스팅의 제목에도 불구하고 어떤 내용도 2020년에 국한되지 않는다는 것이다. 기본 개념과 중요한 개념이 바뀌지 않기 때문이다.\n\n안드로이드 생태계에 더 궁금하다면 지난 포스팅 [2019년말 네이티브 안드로이드 개발 트렌드](https://www.techyourchance.com/the-state-of-native-android-development-november-2019/)를 참고하라. 하지만 좋은 안드로이드 개발자가 되려면 기본적이고 중요한 것들에 더 집중하길 바란다.\n\n","fields":{"slug":"/2020_07_24_Android_Developer_Skills_for_2020/"},"frontmatter":{"title":"[번역] Android Developer Skills for 2020","published":true}}},{"node":{"rawMarkdownBody":"\n\n## 디스크 컨트롤러(lv.3)\n\n[문제 링크](https://programmers.co.kr/learn/courses/30/lessons/42627)\n\nclock 을 선언하여 시간을 잰다. min타임에 최대값 1000 을 넣어 반복할때마다 1000으로 초기화 해준다. \n\njobs 를 하나씩 뽑아서 clock 이하 중 최소작업시간에 해당되는 job 을 현재 작업으로 할당한다. \n\n할당되는 조건을 만족하지 못하면 clock 을 증가시키고 반복문을 다음으로 넘긴다.\n\n할당이 된 경우 jobs 에 할당된 job 을 지우고 해당 job 의 작업시간을 clock 에 더해준다. \n\n모든 job 의 작업시간을 다 더한 후 job 수로 나누면 결과값 완성\n\n-> Priority Queue 를 쓰지 않아 시간이 오래걸림, 다음 clock 으로 바로 넘어가지 않고 더하면서 반복문을 돌고 있으므로 올래걸림\n\n```c++\nint solution(vector<vector<int>> jobs) {\n    int answer = 0;\n    int clock = 0;\n    int sum = 0;        \n    int minDist = 1000;\n    int currentJobIndex = -1;\n    int size = jobs.size();    \n    while(jobs.size() > 0){\n        for(int i = 0 ; i < jobs.size() ; i++){\n            vector<int> job = jobs[i];\n            if(job[0] <= clock && job[1] <= minDist){                \n                minDist = job[1];\n                currentJobIndex = i;\n            }                \n        }        \n        if(currentJobIndex == -1 )\n        {\n            clock++;\n            continue;\n        }\n        vector<int> job = jobs[currentJobIndex];\n        jobs.erase(jobs.begin() + currentJobIndex);\n        clock += job[1];        \n        sum += (clock - job[0]);        // endtime - requesttime        \n        currentJobIndex = -1;\n        minDist = 1000;\n    }    \n    answer = sum/size;    \n    \n    return answer;\n}\n```\n\n**다른방법**\n\n우선순위 큐를 사용하여 구하는것이 수행시간을 줄이는데 도움이 됨\n\n1. Priority Queue 를 이용하돼 어떠한 값을 top 둘것인가 비교연산자를 만들어줌, 작업시간이 가장 작은 것을 top 에 두는 큐 만들기\n2. 현재 시간에 들어올 수 있는 job을 검사하여 들어올 수 있으면 모두 priority Queue 에 넣어주기\n3. Queue 에 있는 것을 꺼내어 작업시간 계산, 다음 시간 계산 or Queue 가 비어 있으면 다음 작업시간계산해서 더해주고 다시 1번으로\n\n\n```c++\nstruct minCmp{\n    bool operator()(vector<int> a, vector<int> b){\n        return a.at(1)>b.at(1);\n    }\n};\n\nint solution(vector<vector<int>> jobs) {\n    int i = 0;\n    priority_queue<vector<int>, vector<vector<int>>, minCmp> pq;\n    long long result = 0;\n    sort(jobs.begin(), jobs.end());\n    long long clock = jobs[0][0];\n    while(i < jobs.size() || !pq.empty()){\n        while( jobs.size() > i && jobs[i][0] <= clock){\n            pq.push(jobs[i++]);\n        }\n        if(!pq.empty()){\n            clock += pq.top()[1];\n            result += clock - pq.top()[0];\n            pq.pop();\n        } else {\n            clock = jobs[i][0];\n        }\n    }\n    return result/jobs.size();\n}\n```\n## reference\n\n아래 사이트에 동일한 문제가 있다.\n\nhttps://www.hackerrank.com/challenges/minimum-average-waiting-time/problem\n\n다른점은 테스트 케이스가 매우 크므로 long long 타입으로 처리해야한다.(이것때문에 로직이 틀린줄 알고 몇시간 삽질한건 비밀....)","fields":{"slug":"/2020_04_09_Minimum Average Waiting Time/"},"frontmatter":{"title":"[Algorithm][프로그래머스] 디스크 컨트롤러","published":true}}},{"node":{"rawMarkdownBody":"\n원문 : https://www.hackerrank.com/challenges/crush/problem\n\n배열의 길이, 배열의 구간별 가중치값들이 더해졌을 때 가장 높은 값을 가지고 있는 구간의 값을 출력하는 문제\n\n```\na b k\n1 5 3\n4 8 7\n6 9 1\n````\na, b 는 구간을 나타내고 k 는 가중치 값을 나타낸다.\n-> 1 5 3 은 1에서 5까지의 구간에 3을 더하라 \n\n```\nindex->\t 1 2 3  4  5 6 7 8 9 10\n\t      [0,0,0, 0, 0,0,0,0,0, 0]\n\t      [3,3,3, 3, 3,0,0,0,0, 0]\n\t      [3,3,3,10,10,7,7,7,0, 0]\n\t      [3,3,3,10,10,8,8,8,1, 0]\n  ```\n각 라인에 따라 구간 값을 더하면 위와 같이 된다.\n\n따라서 처음으로 드는 생각은 위와 같은 과정으로 로직을 짜게 된다.\n\n각 라인을 반복문으로 돌면서 해당 구간을 따라가며 값을 더해주면 당연히 O(n<sup>2</sup>)시간이 걸리게 된다.\n\n시간을 줄일려면 다른 방법을 사용하면 되는데 일단 n+1 사이즈 배열을 선언하고\n\n구간별 값을 시작지점에 더하고 끝지점+1 에 구간별 값을 빼준다.\n\n반복문이 끝나고 배열의 값을 n 까지 모두 더하다 보면 가장 큰 구간의 값을 찾을수 있다. \n\n```c++\nlong arrayManipulation(int n, vector<vector<int>> queries) {\n    vector<long> output(n+1,0);\n    long max = 0;\n    long x = 0;\n    for(int i = 0 ; i < queries.size(); i++){\n        vector<int> per = queries[i];\n        int a = per[0]; int b = per[1]; int k = per[2];\n        output[a-1] += k;\n        if(b + 1 <= n) output[b] -= k;\n        \n    }\n    for(int i = 0 ; i < n ; i++){\n        x += output[i];\n        if(max < x) max = x;\n    }\n    return max;\n}\n```\n코틀린 코드\n\n```kotlin\nfun arrayManipulation(n: Int, queries: Array<Array<Int>>): Long {\n    var arr = LongArray(n+1, {0})\n    var result: Long = 0\n    var temp: Long = 0\n    queries.forEach{v ->\n        arr[v[0]-1] += v[2].toLong()\n        arr[v[1]] -= v[2].toLong()\n    }\n    arr.forEach{ \n        temp += it\n        if(result < temp) result = temp\n        }\n    \n    return result\n\n}\n```\n\n구간별 값은 구간에만 해당되고 구간이 끝나면 다시 빼는 생각을 해야 나올 수 있는 발상\n\n","fields":{"slug":"/2020_04_06_Array Manipulation/"},"frontmatter":{"title":"[Algorithm][hackerrank] Array Manipulation","published":true}}},{"node":{"rawMarkdownBody":"\n\n원문 : https://www.hackerrank.com/challenges/between-two-sets/problem\n\nYou will be given two arrays of integers and asked to determine all integers that satisfy the following two conditions:\n\nThe elements of the first array are all factors of the integer being considered\nThe integer being considered is a factor of all elements of the second array\nThese numbers are referred to as being between the two arrays. You must determine how many such numbers exist.\n\nFunction Description\n\nComplete the getTotalX function in the editor below. It should return the number of integers that are betwen the sets.\n\ngetTotalX has the following parameter(s):\n\na: an array of integers\nb: an array of integers\n\n요약하자면 배열 a의 공배수의 집합\n배열 b의 공약수의 집합\n이 둘의 공집합의 원소의 갯수를 출력하는 문제 (번역이 잘 안되서 한참을 다시 읽어봄)\n\n배열을 따로 만들어서 해결해야하나 라는 고민이 먼저 들지만 포럼에서 결론을 내놓았다.\n\n결과값에서 요구하는게 아니라면 다르게 접근할수도 있겠구나 생각함\n\n```c++\n// 최대 공약수\n int gcd(int a, int b){\n     while(b!=0){\n         int r = a%b;\n         a = b;\n         b = r;\n     }\n     return a;\n }\n// 배열에서의 최대 공약수\n int gcd(vector<int> input){\n     int result = input[0];\n     for(int i = 1 ; i < input.size(); i++){\n         result = gcd(result, input[i]);\n     }\n     return result;\n }\n// 최소 공배수\n int lcm(int a, int b){\n     return a*b/ gcd(a,b);\n }\n // 배열에서의 최소 공배수\n int lcm(vector<int> input){\n     int result = input[0];\n     for(int i = 1 ; i < input.size(); i++){\n         result = lcm(result, input[i]);\n     }\n     return result;\n }\n\nint getTotalX(vector<int> a, vector<int> b) {\n    int f = lcm(a);     // 배열 a의 최소 공배수를 구한다.\n    int l = gcd(b);     // 배열 b의 최대 공약수를 구한다.\n    int count = 0;\n    for(int i = f, j = 2; i <= l; i= f*j, j++){   // 반복문 시작에 배열 a의 최소 공배수를 넣고 최소 공배수를 *2, *3 식으로 곱하면서 배열 b의 최대 공약수에 도달할때까지 반복\n        if(l%i==0) count++;       // 반복하는 동안 배열 b의 최대 공약수를 나눌 수 있으면 카운트\n    }\n    return count;\n}\n```\n","fields":{"slug":"/2020_04_06_between-two-sets/"},"frontmatter":{"title":"[Algorithm][hackerrank] Between Two Sets","published":true}}},{"node":{"rawMarkdownBody":"\n원문 : https://leetcode.com/problems/longest-substring-without-repeating-characters/\n\nGiven a string, find the length of the longest substring without repeating characters.\n\n__Example 1:__\n```\nInput: \"abcabcbb\"\nOutput: 3 \n\nExplanation: The answer is \"abc\", with the length of 3. \n```\n__Example 2:__\n```\nInput: \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n```\n__Example 3:__\n```\nInput: \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n```\n\nThe idea is simple, I use last[] to record the last position of characters. beginPos and lastPos record the range of the current sub string.\n\nFor a character, if the last position of a character is before the beginPos, we increase the sub string, otherwise we start from the last position + 1.\n```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int last[256];\n        int maxSize = 0;        \n        int beginPos = 0;\n        fill_n(last, 256, -1);\n        for (int lastPos = 0; lastPos < s.size(); lastPos++) {\n           if (last[s[lastPos]] < beginPos) {   \n               // substring 길이 증가\n               maxSize = max(maxSize, lastPos-beginPos+1);\n           } else {     // \n               beginPos = last[s[lastPos]] + 1;     //substring 다시 시작\n           }\n           last[s[lastPos]] = lastPos;  // s[lastPos] 의 위치 저장\n        }\n        \n        return maxSize;\n    }\n};\n```  \n\n각 char 의 위치를 저장하면서 substring 의 길이를 업데이트 해준 뒤 가장 긴 substring 길이를 저장한다. <br>\nlast[s[lastPos]] : s[lastPos] 문자가 있는 마지막 위치, 초기값 -1 <br>\nbeginPos : substring 시작지점  <br>\ns 길이만큼 반복하며 last[] 에 해당 char 가 이전에 어느 위치에 있는지 검사\nif 전에 위치가 substring 시작위치보다 앞에 있으면 substring 길이 증가, maxSize 와 비교해서 큰 값 저장\nelse 전에 위치가 substring 시작 위치와 같거나 뒤에 있으면 substring 끝 시작 위치 다시 저장\n\n\n`다른코드`\n```c++\nint lengthOfLongestSubstring(string s) {\n        vector<int> dict(256, -1);\n        int maxLen = 0, start = -1;\n        for (int i = 0; i != s.length(); i++) {\n            if (dict[s[i]] > start)\n                start = dict[s[i]];\n            dict[s[i]] = i;\n            maxLen = max(maxLen, i - start);\n        }\n        return maxLen;\n    }\n```\n","fields":{"slug":"/2020_04_04_longest-substring-without-repeating-characters/"},"frontmatter":{"title":"[Algorithm][LeetCode] find the length of the longest substring without repeating characters","published":true}}},{"node":{"rawMarkdownBody":"\n# Scope Functions\n\n가본적으로 5개의 함수가 하는 일은 같다(블록안에 코드를 실행). 다만 어떻게 객체가 블록안에서 사용되는지와 return 값이 어떻게 되는지에 따라 조금씩 다르다.\n\n일반적으로 다음과 같이 쓰인다. \n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\ndata class Person(var name: String, var age: Int, var city: String) {\n    fun moveTo(newCity: String) { city = newCity }\n    fun incrementAge() { age++ }\n}\n\nfun main() {\n//sampleStart\n    Person(\"Alice\", 20, \"Amsterdam\").let {\n        println(it)\n        it.moveTo(\"London\")\n        it.incrementAge()\n        println(it)\n    }\n//sampleEnd\n}\n```\n\n</div>\n\n\n`let`을 쓰지 않는다면 다음과 같이 쓸때마다 같은 이름을 반복해서 쓰게 된다.\n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\ndata class Person(var name: String, var age: Int, var city: String) {\n    fun moveTo(newCity: String) { city = newCity }\n    fun incrementAge() { age++ }\n}\n\nfun main() {\n//sampleStart\n    val alice = Person(\"Alice\", 20, \"Amsterdam\")\n    println(alice)\n    alice.moveTo(\"London\")\n    alice.incrementAge()\n    println(alice)\n//sampleEnd\n}\n```\n\n</div>\n\nscope function 은 딱히 새로운 기술을 제공하는건 아니고 코드를 간략하게 하고 읽기쉽게 만들어준다. \n\n경우에 따라 적합한 것을 골라쓰는게 조금 어려울 수도 있다. 코드작성의 의도나 일관성에 따라 선택하여 쓸 수 있다. 아래에서 scope function 를 용도에 따라 구분하여 사용하는 법에 대해서 서술하겠다.\n\n## 차이점\n\nscope function 은 언뜻보기엔 비슷하기 때문에 각각의 차이점을 이해하는게 중요하다. 구별되는 두가지 차이점은 다음과 같다.\n* 객체를 접근하는 방식 -> 일반 함수와 확장 함수로 구별\n* 리턴 값 \n\n### 객체 접근: `this` 혹은 `it`\n\n\nscope function 에서의 객체 참조는 실제 이름대신 람다 리시버 `this` 와 람다 매개변수 `it`으로 접근한다. 기능은 같지만 각기 다른 경우에 어떠한 장단점이 있는지 알아보자\n\n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\nfun main() {\n    val str = \"Hello\"\n    // this\n    str.run {\n        println(\"The receiver string length: $length\")\n        //println(\"The receiver string length: ${this.length}\") // does the same\n    }\n\n    // it\n    str.let {\n        println(\"The receiver string's length is ${it.length}\")\n    }\n}\n```\n\n</div>\n<br>\n\n### __this__\n\n`run`, `with`, `apply` 에서는 람다 리시버인 `this`로 객체에 접근한다. 그리고 람다 안에서는 일반적인 클래스 함수에 있는 객체처럼 사용할 수 있다. `this`를 생략하고 사용할 수 있지만 생략할 경우 리시버의 멤버인지 외부 객체/함수 인지 구분하기 어렵다. 그래서 `this`를 사용하는걸 추천\n\n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\ndata class Person(var name: String, var age: Int = 0, var city: String = \"\")\n\nfun main() {\n//sampleStart\n    val adam = Person(\"Adam\").apply { \n        age = 20                       // same as this.age = 20 or adam.age = 20\n        city = \"London\"\n    }\n    println(adam)\n//sampleEnd\n}\n```\n\n</div>\n<br>\n\n### __it__\n\n`let` 과 `also` 에서는 람다 매개변수인 `it`으로 객체 참조. \n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\nimport kotlin.random.Random\n\nfun writeToLog(message: String) {\n    println(\"INFO: $message\")\n}\n\nfun main() {\n//sampleStart\n    fun getRandomInt(): Int {\n        return Random.nextInt(100).also {\n            writeToLog(\"getRandomInt() generated value $it\")\n        }\n    }\n    \n    val i = getRandomInt()\n//sampleEnd\n}\n```\n\n</div>\n\n`it` 은 이름변경이 가능하다. 다음과 같이\n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\nimport kotlin.random.Random\n\nfun writeToLog(message: String) {\n    println(\"INFO: $message\")\n}\n\nfun main() {\n//sampleStart\n    fun getRandomInt(): Int {\n        return Random.nextInt(100).also { value ->\n            writeToLog(\"getRandomInt() generated value $value\")\n        }\n    }\n    \n    val i = getRandomInt()\n//sampleEnd\n}\n```\n\n</div>\n\n### Return value\n\n\n리턴 값으로 구별하면 다음과 같다.\n\n* `apply`, `also` 은 리시버 객체 리턴\n* `let`, `run`,`with` 은 람다 결과 리턴\n\n결과 값을 가지고 다음코드에서 무엇을 할지에 따라 선택해서 사용하면 됨\n\n#### __Context object__\n\n`apply`, `also` 는 객체 자신을 리턴하기 때문에 다음과 같이 chain 형태로 사용할 수 있다.\n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\nfun main() {\n//sampleStart\n    val numberList = mutableListOf<Double>()\n    numberList.also { println(\"Populating the list\") }\n        .apply {\n            add(2.71)\n            add(3.14)\n            add(1.0)\n        }\n        .also { println(\"Sorting the list\") }\n        .sort()\n//sampleEnd\n    println(numberList)\n}\n```\n\n</div>\n\n함수의 리턴 결과로도 다음과 같이 쓸 수 있다.\n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\nimport kotlin.random.Random\n\nfun writeToLog(message: String) {\n    println(\"INFO: $message\")\n}\n\nfun main() {\n//sampleStart\n    fun getRandomInt(): Int {\n        return Random.nextInt(100).also {\n            writeToLog(\"getRandomInt() generated value $it\")\n        }\n    }\n    \n    val i = getRandomInt()\n//sampleEnd\n}\n```\n\n</div>\n\n#### 람다 결과\n\n\n`let`, `run`, `with` 은 람다 결과 값을 리턴한다. 그래서 결과값을 변수에 넣거나 결과에 체이닝 연산을 걸 수 있다.\n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\")\n    val countEndsWithE = numbers.run { \n        add(\"four\")\n        add(\"five\")\n        count { it.endsWith(\"e\") }\n    }\n    println(\"There are $countEndsWithE elements that end with e.\")\n//sampleEnd\n}\n```\n\n</div>\n\n또한, 리턴값을 무시하고 변수를 위한 임시 scope 를 만들 수도 있다.\n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\")\n    with(numbers) {\n        val firstItem = first()\n        val lastItem = last()        \n        println(\"First item: $firstItem, last item: $lastItem\")\n    }\n//sampleEnd\n}\n```\n\n</div>\n\n## Functions\n\n각각의 상황에 맞는 scope function 선택을 위해 좀더 상세한 설명\n\n### `let`\n\n**객채**는 매개변수으로 사용(`it`). \n**리턴값**은 람다 결과.\n\n`let`은 콜체인의 결과에서 하나 이상의 함수 호출하는데 사용할 수 있다.\n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\", \"five\")\n    val resultList = numbers.map { it.length }.filter { it > 3 }\n    println(resultList)    \n//sampleEnd\n}\n```\n\n</div>\n\n`let` 을 사용하면 다음과 같이 고칠 수 있다.\n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\", \"five\")\n    numbers.map { it.length }.filter { it > 3 }.let { \n        println(it)\n        // and more function calls if needed\n    } \n//sampleEnd\n}\n```\n\n</div>\n\n만약 블록이 `it` 을 매개변수로 갖는 함수를 포함한다면 람다대신에 `::` 매서드 레퍼런스를 사용할 수 있다.\n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\", \"five\")\n    numbers.map { it.length }.filter { it > 3 }.let(::println)\n//sampleEnd\n}\n```\n\n</div>\n\n`let` 은 `?.` 를 붙여 non-null value 검사도 할 수 있다. \n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\nfun processNonNullString(str: String) {}\n\nfun main() {\n//sampleStart\n    val str: String? = \"Hello\"   \n    //processNonNullString(str)       // compilation error: str can be null\n    val length = str?.let { \n        println(\"let() called on $it\")        \n        processNonNullString(it)      // OK: 'it' is not null inside '?.let { }'\n        it.length\n    }\n//sampleEnd\n}\n```\n\n</div>\n\n`let`의 다른 사용법에는 코드 가독성을 위해 scope를 제한하는 법도 있다. 객체를 위한 새로운 변수를 정의하기 위해 `it` 대신 람다 매개변수로 이름을 지정할 수 있다.\n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\nfun main() {\n//sampleStart\n    val numbers = listOf(\"one\", \"two\", \"three\", \"four\")\n    val modifiedFirstItem = numbers.first().let { firstItem ->\n        println(\"The first item of the list is '$firstItem'\")\n        if (firstItem.length >= 5) firstItem else \"!\" + firstItem + \"!\"\n    }.toUpperCase()\n    println(\"First item after modifications: '$modifiedFirstItem'\")\n//sampleEnd\n}\n```\n\n</div>\n\n### `with`\n\n\n확장함수가 아닌 일반함수: 객체는 매개변수로 전달, 객체를 람다 안에서 리시버로 받는다(`this`). **리턴값**은 람다결과\n\n\n`with`은 람다 결과없는 객체를 위해 사용하는 것을 추천 `with`는 \"이 객체로 다음과 같이 실행\" 으로 읽혀질 수 있다.\n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\")\n    with(numbers) {\n        println(\"'with' is called with argument $this\")\n        println(\"It contains $size elements\")\n    }\n//sampleEnd\n}\n```\n\n</div>\n\n`with`의 다른 사용법은 객체의 멤버나 함수를 사용해서 값을 계산할 때 \n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\")\n    val firstAndLast = with(numbers) {\n        \"The first element is ${first()},\" +\n        \" the last element is ${last()}\"\n    }\n    println(firstAndLast)\n//sampleEnd\n}\n```\n\n</div>\n\n### `run`\n\n\n**객체**는 리시버로 사용된다 (`this`). **리턴값**은 람다 결과 값\n\n\n`run`은 `with`와 비슷하지만 `let`처럼 객체의 확장함수로 동작한다.\n\n`run`은 객체 초기화와 리턴값 계산을 하는 람다에서 유용하게 쓸 수 있다.\n\n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\n\nclass MultiportService(var url: String, var port: Int) {\n    fun prepareRequest(): String = \"Default request\"\n    fun query(request: String): String = \"Result for query '$request'\"\n}\n\nfun main() {\n//sampleStart\n    val service = MultiportService(\"https://example.kotlinlang.org\", 80)\n\n    val result = service.run {\n        port = 8080\n        query(prepareRequest() + \" to port $port\")\n    }\n    \n    // the same code written with let() function:\n    val letResult = service.let {\n        it.port = 8080\n        it.query(it.prepareRequest() + \" to port ${it.port}\")\n    }\n//sampleEnd\n    println(result)\n    println(letResult)\n}\n```\n\n</div>\n\n`run`호출은 일반함수로 사용할 수도 있다. 일반함수 `run`은 인자가 없는 익명 함수처럼 동작한다. \n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\nfun main() {\n//sampleStart\n    val hexNumberRegex = run {\n        val digits = \"0-9\"\n        val hexDigits = \"A-Fa-f\"\n        val sign = \"+-\"\n        \n        Regex(\"[$sign]?[$digits$hexDigits]+\")\n    }\n    \n    for (match in hexNumberRegex.findAll(\"+1234 -FFFF not-a-number\")) {\n        println(match.value)\n    }\n//sampleEnd\n}\n```\n\n</div>\n\n### `apply`\n\n**객체**는 리시버로 사용된다 (`this`). **리턴값** 은 객체 자기자신이다.\n\n코드 블록에서 `apply`는 리턴값을 가지지 않고 리시버 객체의 멤버 연산에 사용된다. 객체구성이 일반적인 경우이다. 이런한 호출은 \"_이러한 할당을 오브젝트에 적용한다_\"라는 식으로 읽을 수 있다.\n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\ndata class Person(var name: String, var age: Int = 0, var city: String = \"\")\n\nfun main() {\n//sampleStart\n    val adam = Person(\"Adam\").apply {\n        age = 32\n        city = \"London\"        \n    }\n    println(adam)\n//sampleEnd\n}\n```\n\n</div>\n\n\n리시버가 리턴값으로 사용되면 `apply`를 좀더 복잡한 연산에 콜체인으로 사용할 수 있다.\n\n### `also`\n\n**객체**는 매개변수(`it`)로 전달된다. **리턴값**은 객체 자신\n\n\n`also`는 객체를 매개변수로 처리하는데 유용하다. 로깅같이 디버깅 정보를 출력하는 처리 등 객체의 멤버보단 객체 참조가 필요한 동작에 사용된다. \n\n`also`를 코드에서 읽을 때 \"_그리고 객체로 이 동작도 수행하라_\"라는 뜻으로 해석할 수 있다.\n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\nfun main() {\n//sampleStart\n    val numbers = mutableListOf(\"one\", \"two\", \"three\")\n    numbers\n        .also { println(\"The list elements before adding new one: $it\") }\n        .add(\"four\")\n//sampleEnd\n}\n```\n\n</div>\n\n## 함수 선택\n\n사용목적에 따른 올바른 scope function의 선택을 돕기위해 비교정리를 하면 다음과 같다.\n\n|Function|Object reference|Return value|Is extension function|\n|---|---|---|---|\n|`let`|`it`|Lambda result|Yes|\n|`run`|`this`|Lambda result|Yes|\n|`run`|-|Lambda result|No: called without the context object|\n|`with`|`this`|Lambda result|No: takes the context object as an argument.|\n|`apply`|`this`|Context object|Yes|\n|`also`|`it`|Context object|Yes|\n\n\n의도한 목적에 따른 scope function 선택에 관한 가이드는 다음과 같다.\n\n\n* non-null 객체에 대한 람다 실행 : `let`\n* 로컬 scope 에서의 변수 표현 : `let`\n* 객체 구성 : `apply`\n* 객체 구성과 결과값 계산 : `run`\n* 블럭내에서 실행할 범위 지정 : 일반함수 `run`\n* 추가적인 동작 ( 로깅같이 디버깅에 사용되는 동작) : `also`\n* 객체단위로 동작하는 기능 : `with`\n\nscope function 은 코드를 줄이는 방법 중에 하나이긴 하지만 남용은 피하자 ( 코드 가독성을 떨어뜨리거나 에러가 나는 경우도...). scope function 을 chaining 해서 쓰게 되면 `this` 나 `it`의 값이 헷갈리거나 현재 객체를 혼동할 수 있다.\n\n### Scope Function 선택하는법\n![decide_scope](./scope_decision.png)\n\n\n## `takeIf` and `takeUnless`\n\nstandard library 에는 `takeIf` 와 `takeUnless` 함수가 포합되어 있다. 이 함수들로 콜 체인에서 객체상태를 체크할 수 있다.\n\n`takeIf` 는 조건에 맞는 것을 리턴, 없을 경우 `null`리턴\n`takeUnless`는 조건에 맞지 않는 것을 리턴, 없을 경우 `null`리턴\n객체는 람다 매개변수 `it`로 접근 가능\n\n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\nimport kotlin.random.*\n\nfun main() {\n//sampleStart\n    val number = Random.nextInt(100)\n\n    val evenOrNull = number.takeIf { it % 2 == 0 }\n    val oddOrNull = number.takeUnless { it % 2 == 0 }\n    println(\"even: $evenOrNull, odd: $oddOrNull\")\n//sampleEnd\n}\n```\n\n</div>\n\n확장함수이므로 `?.`으로 체이닝해서 null 체크가 가능하다. \n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\nfun main() {\n//sampleStart\n    val str = \"Hello\"\n    val caps = str.takeIf { it.isNotEmpty() }?.toUpperCase()\n   //val caps = str.takeIf { it.isNotEmpty() }.toUpperCase() //compilation error\n    println(caps)\n//sampleEnd\n}\n```\n\n</div>\n\n\n`takeIf` 와 `takeUnless` 는 scope function과 같이쓰면 유용하다. 좋은 예는 `let`으로 체이닝해서 코드를 실행할 때 `takeIf`에 `?.`을 달아서 `let`을 실행하면 null safe 한 실행을 보장할 수 있다.\n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\nfun main() {\n//sampleStart\n    fun displaySubstringPosition(input: String, sub: String) {\n        input.indexOf(sub).takeIf { it >= 0 }?.let {\n            println(\"The substring $sub is found in $input.\")\n            println(\"Its start position is $it.\")\n        }\n    }\n\n    displaySubstringPosition(\"010000011\", \"11\")\n    displaySubstringPosition(\"010000011\", \"12\")\n//sampleEnd\n}\n```\n\n</div>\n\n아래 코드는 standard library function을 쓰지 않을 때의 코드이다.\n\n<div class=\"sample\" markdown=\"1\" theme=\"idea\">\n\n```kotlin\nfun main() {\n//sampleStart\n    fun displaySubstringPosition(input: String, sub: String) {\n        val index = input.indexOf(sub)\n        if (index >= 0) {\n            println(\"The substring $sub is found in $input.\")\n            println(\"Its start position is $index.\")\n        }\n    }\n\n    displaySubstringPosition(\"010000011\", \"11\")\n    displaySubstringPosition(\"010000011\", \"12\")\n//sampleEnd\n}\n```\n\n</div>\n\n## Reference\n\n https://kotlinlang.org/docs/reference/scope-functions.html\n\n https://github.com/JetBrains/kotlin-web-site/blob/master/pages/docs/reference/scope-functions.md\n\n https://tourspace.tistory.com/56\n\n","fields":{"slug":"/2020_04_03_scope_function/"},"frontmatter":{"title":"[Kotlin][번역 및 요약] Scope Function","published":true}}},{"node":{"rawMarkdownBody":"\n원본 : https://www.geeksforgeeks.org/sort-an-array-of-0s-1s-and-2s/\n\n## Sort an array of 0s, 1s and 2s\n\n0,1,2 으로 이루어진 배열을 정렬하라\n\n가장 심플한 방법은 [0,1,2 를 세는방법](https://www.geeksforgeeks.org/sort-array-0s-1s-2s-simple-counting/)이지만 배열을 한번 더 써야하는 단점이 있음\n\n배열을 네가지의 영역으로 나눈다. \n1. a[0..Lo-1] zeroes \n2. a[Lo..Mid-1] ones \n3. a[Mid..Hi] unknown\n4. a[Hi+1..N-1] twos \n\nLo 와 Mid 에 해당되는 인덱스를 0으로 놓고 시작하면서\nLo 에 있는 값은 0\nHi 에 있는 값은 2\nMid 에 있는 값은 1 이라고 생각하면서 인덱스를 더하거나 줄여가면서 값을 바꿔준다.\n예를들어 a[Mid] 에 있는 값이 0이면 a[Lo] 와 swap 하고 Lo++  \na[Mid] 에 있는 값이 1이면 Mid++\na[Mid] 에 있는 값이 2이면 a[Hi] 와 swap  하고 Hi--\nMid 와 Hi 가 같아질 때까지 반복한다.\n\n```c++\n// C++ program to sort an array \n// with 0,1 and 2 in a single pass \n#include<bits/stdc++.h> \nusing namespace std; \n\n\n\n// Function to sort the input array, \n// the array is assumed \n// to have values in {0, 1, 2} \nvoid sort012(int a[], int arr_size) \n{ \n\tint lo = 0; \n\tint hi = arr_size - 1; \n\tint mid = 0; \n\t\n\t// Iterate till all the elements \n\t// are sorted \n\twhile (mid <= hi) \n\t{ \n\t\tswitch (a[mid]) \n\t\t{ \n\t\t\t\n\t\t\t// If the element is 0 \n\t\tcase 0: \n\t\t\tswap(a[lo++], a[mid++]); \n\t\t\tbreak; \n\t\t\t\n\t\t\t// If the element is 1 . \n\t\tcase 1: \n\t\t\tmid++; \n\t\t\tbreak; \n\t\t\t\n\t\t\t// If the element is 2 \n\t\tcase 2: \n\t\t\tswap(a[mid], a[hi--]); \n\t\t\tbreak; \n\t\t} \n\t} \n} \n\n\n\n// Function to print array arr[] \nvoid printArray(int arr[], int arr_size) \n{ \n\t// Iterate and print every element \n\tfor (int i = 0; i < arr_size; i++) \n\t\tcout << arr[i] << \" \"; \n\n} \n\n// Driver Code \nint main() \n{ \n\tint arr[] = {0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1}; \n\tint n = sizeof(arr)/sizeof(arr[0]); \n\t\n\tsort012(arr, n); \n\n\tcout << \"array after segregation \"; \n\t\n\tprintArray(arr, n); \n\n\treturn 0; \n} \n\n// This code is contributed by Shivi_Aggarwal \n\n```\n\n\n\n코틀린 코드도 추가\n\n\n```kotlin\nimport java.util.Collections.swap\n\nfun sort012(arr: MutableList<Int>){\n    val size = arr.size\n    var lo=0\n    var hi= size - 1\n    var mid = 0\n    while(mid<=hi){\n        when(arr[mid]){\n            0 -> swap(arr, lo++, mid++)\n            1 -> mid++\n            2 -> swap(arr, mid, hi--)\n        }\n    }\n}\n\n```","fields":{"slug":"/2020_03_28_sorting_012/"},"frontmatter":{"title":"[Algorithm] 0, 1, 2로 이루어진 배열 정렬하기","published":true}}},{"node":{"rawMarkdownBody":"\n\n원본 : https://www.geeksforgeeks.org/cutting-a-rod-dp-13/\n\n## Cutting a Rod | DP-13\n\n다음과 같이 단위 길이당 막대의 가격이 주어졌을 때 n 길이의 막대로 얻을 수 있는 최고가격을 구하라. 예를 들어 길이가 8인 막대가 주어졌을 때 최고 가격은 22이다. ( 길이가 2, 6인 막대로 자름)\n\n\n|length| 1 |  2 |  3 |  4 |  5 |  6 |  7 |  8  |\n|------|---|----|---|-----|---|----|----|-----|\n|price    | 1|   5|   8|   9|  10|  17|  17|  20|\n\n\n단순한 방법으로 접근하면 길이의 모든 조합을 찾아서 가장 높은 가격을 계산한다. 하지만 complexity 가 많이 걸림. DP 방식으로 어떻게 풀 수 있는지 알아보자\n\n__1) 효율적인 구조:__ </br>\n\n각각 다른 위치에서 통나무를 자르고 나서 가격을 계산한뒤 최고 값을 구할 수 있다. 이를 재귀함수로 구현할 수 있다.\n\n\ncutRod(n) 를 길이가 n 일 때 최고 값이라고 가정하면 점화식은 다음과 같다. \n\ncutRod(n) = max(price[i] + cutRod(n-i-1)) for all i in {0, 1 .. n-1} <br>\nmax(i길이의 값 + cutRod(n-i-1)) : price[i] 의 값과 나머지 길이의 가격의 최대 값의 합\n\n__2) 중복문제__</br>\n\n\n다음과 같이 간단한 재귀함수를 구현할 수 있다.\n\n```C++\nint cutRod(int price[], int n) \n{ \n   if (n <= 0) \n     return 0; \n   int max_val = 0; \n  \n   // Recursively cut the rod in different pieces and compare different  \n   // configurations \n   for (int i = 0; i<n; i++) \n         max_val = max(max_val, price[i] + cutRod(price, n-i-1)); \n  \n   return max_val; \n} \n```\n\n막대의 길이가 4라고 가정하면 다음과 같은 재귀트리가 생성된다. \n\n```\ncR() ---> cutRod() \n\n                             cR(4)\n                  /        /           \n                 /        /              \n             cR(3)       cR(2)     cR(1)   cR(0)\n            /  |         /         |\n           /   |        /          |  \n      cR(2) cR(1) cR(0) cR(1) cR(0) cR(0)\n     /        |          |\n    /         |          |   \n  cR(1) cR(0) cR(0)      cR(0)\n   /\n /\nCR(0)\n```\n\n위의 트리를 참고하면 cR(2) 같은 경우 두번 계산되게 된다. 트리의 depth 가 깊으면 깊을수록 이런 중복된 계산이 많아질 것이다. 따라서 이렇게 계산된 값들은 미리 저장해두는 것이 좋다. \n\n```C++\nint cutRod(int price[], int n) \n{ \n   int val[n+1]; \n   val[0] = 0; \n   int i, j; \n  \n   // Build the table val[] in bottom up manner and return the last entry \n   // from the table \n   for (i = 1; i<=n; i++) \n   { \n       int max_val = 0; \n       for (j = 0; j < i; j++) \n         max_val = max(max_val, price[j] + val[i-j-1]); \n       val[i] = max_val; \n   } \n  \n   return val[n]; \n} \n```\nval[i] 는 i 길이 일때 최대값, 길이는 1부터 시작 <br>\n\nTime Complexity 는 O(n<sup>2</sup>)로 첫번째 방법의 worst case 보다 낫다. \n\n재귀함수 구현은 다음과 같음\n```C++\nint cutting_rod_recurv(int price[], int n, int cut)\n{\n    if( cut == n-1 )\n    {\n        return price[n-1];\n    }\n\n    return std::max( (price[cut] + price[n-1-cut-1]), cutting_rod_recurv(price, n, cut+1) );\n}\n```\n\n\n\n\n","fields":{"slug":"/2020_03_27_cutting_rod/"},"frontmatter":{"title":"[Algorithm] 막대 자르기","published":true}}},{"node":{"rawMarkdownBody":"\n블로그 포스팅하는데 글 작성 후  ```npm run deploy```  명령을 쳐야 하는게 번거로웠다. 더불어 그때그때 commit, push 등을 해줘야한다는 것도.....\n\n깃헙 action 이 나온지 좀 됐지만 세팅해야지 해야지 하다가 오늘에야 세팅\n\n검색해보니 누가 스크립트를 이미 만들어 놓은것이 있어서 쉽게 해결되었다.\n\nhttps://github.com/marketplace/actions/gatsby-publish\n\n\n[Personnal Access Token](https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line)을 세팅 (권한을 뭐뭐 줘야하는지 헷갈리긴하는데 일단 repo, write:package, read:package, admin:org, user, workflow 이렇게 줬는데 잘 동작했다. 하지만 이렇게 까지는 필요없고 read, write 권한만 있으면 되지 않을까 생각함)하고 해당 repo 세팅에서 Secrets 으로 만들어줘야 한다.\n\nActions 메뉴에서 다음과 같이 Workflow 를 만들어주면 끝\n\n```\nname: Publish\n\non:\n  push:\n    branches: [ develop ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    # Steps represent a sequence of tasks that will be executed as part of the job\n    steps:\n    - uses: actions/checkout@v1\n    - uses: enriikke/gatsby-gh-pages-action@v2\n      with:\n        access-token: ${{ secrets.ACCESS_TOKEN}}\n```\n\n이제 develop 브랜치에 push만 하면 자동으로 빌드되어 배포됨. 자동화하니 편하다.\n\n","fields":{"slug":"/2020_03_27_github_action/"},"frontmatter":{"title":"github action 사용하기 (gatsby 자동 배포)","published":true}}},{"node":{"rawMarkdownBody":"\n\n원문 : https://possiblemobile.com/2013/06/context/\n\n## Android/Context이란 무엇인가\nContext 는 Android 에서 가장 많이(그리고 가장 잘못) 쓰이는 클래스이다.\n\nContext 는 의도치 않게 만들어 쓰기 쉽다. 리소스 로딩, 새 Activity 실행, 시스템 서비스 가져오기, 저장소 파일 경로얻기, View 만들기 등 모든 동작에 Context 가 필요하다. ( 이 밖에도 많이 쓰인다.)\n이 글에서는 Context 가 어떻게 동작하는지 보여주고 안드로이드 앱에서 좀더 효율적으로 사용할 수 있는 팁들을 알아볼 것이다.\n\n### Context Types\n\n모든 Context instances 가 똑같이 만들어 지지는 않는다. 그리고 Android component 에 따라 접근할 수 있는 Context 가 조금 다르다.\n \nApplication - 앱 프로세스에서 싱글톤으로 동작하는 instance 이다. Activity와 Service 에서 getApplication()와 같은 메서드로 접근한다. Context 를 상속받는 객체에서는 getApplicationContext() 로 접근 가능하다. 프로세스 어디에서 어떻게 접근해도 같은 instance 를 받게 된다.\n\nActivity/Service - 같은 API로 구현된 ContextWrapper 에서 상속된다. 하지만 base context 라고 하는 내부 Context instance 에서 모든 메서드 콜을 대신한다. 프레임워크에서 새 Activity 나 Service instance 를 만들면, ContextImpl instance 또한 생성하여 두 component 를 wrapping 한다. 각각의 Activity, Service 와 해당 base context 는 각각 unique 한 instance 로 생성된다.\n\nBroadcastReceiver - 자체로는 Context 가 아니다. 하지만 프레임워크에서 새로운 broadcast 이벤트가 들어오면 onReceive()에 Context 로 전달한다. 이 Instance 는 두개의 중요한 함수(  registerReceiver(), bindService() ) 이 비활성화된 ReceiverRestrictedContext 이다. 이 두 함수는 BroadcastReceiver.onReceive() 에서는 쓸 수 없다. broadcast 를 처리할 때 마다 Context 는 새 Instance 로 처리한다.\n\nContentProvider - 컨텍스트는 아니지만 getContext()를 통해 액세스할 수 있는 컨텍스 트를 생성했을 때 제공된다. ContentProvider 가 호출된 곳에서 로컬로 실행되면(즉, 같은 application process) 같은 Application singleton 으로 리턴된다. 하지만 두개의 프로세스에서 각각 실행될때는 provider가 실행되는 패키지를 나타내는 instance 로 생성된다.\n\n\n## Saved References\n\n다룰 첫번째 이슈는 저장된 instance 를 벗어나는 lifecycle 에 있는 객체나 클래스의 Context 를 참조할 때.\n\nFor example, creating a custom singleton that requires a Context to load resources or access a ContentProvider, and saving a reference to the current Activity or Service in that singleton.\n예를 들어, Context를 사용하여 resource 를 불러오거나 ContentProvider 에 접근하는 커스텀 singleton을 만들 때, 그리고 현재의 Activity 나 Service 의 참조를 singleton 에다 저장하게 되면\n\n### Bad Singleton\n\n```java\npublic class CustomManager {\n    private static CustomManager sInstance;\n \n    public static CustomManager getInstance(Context context) {\n        if (sInstance == null) {\n            sInstance = new CustomManager(context);\n        }\n \n        return sInstance;\n    }\n \n    private Context mContext;\n \n    private CustomManager(Context context) {\n        mContext = context;\n    }\n}\n```\n\n위 코드의 문제는 Context 가 어디서 왔는지도 모르고, Context 가  Activity 나 Service인 경우에는 참조를 들고 있는 것이 안전하지 않다는 것이다. singleton 이 클래스 내부에서 하나의 static 참조로 관리되기 때문에 일어나는 문제이다. 이렇게 되면 singleton 으로 참조되는 모든 객체들은 GC 가 동작하지 않게 된다. 이 Context 가 Activity 라면 activity 안에 있는 모든 view 와 큰 메모리를 차지하는 객체 등이 남아 있어 메모리 누수를 유발한다.\n\n\n이를 방지하기 위해, singleton 은 항상 application context 를 참조하게 구현되어야 한다.\n\n```java\npublic class CustomManager {\n    private static CustomManager sInstance;\n \n    public static CustomManager getInstance(Context context) {\n        if (sInstance == null) {\n            //Always pass in the Application Context\n            sInstance = new CustomManager(context.getApplicationContext());\n        }\n \n        return sInstance;\n    }\n \n    private Context mContext;\n \n    private CustomManager(Context context) {\n        mContext = context;\n    }\n}\n```\n\n이제 Context 가 어디에서 왔는지 신경쓸 필요가 없다. application context 자체가 singleton 이기 때문에 다른 static 참조 해도 메모리 누수가 발생하지 않는다. \n메모리 누수가 발생하는 또 다른 좋은 예는 Background 실행 중인 Thread 또는 pending 핸들러 내부에서 컨텍스트에 대한 참조를 저장하는 것이다. \n\n그렇다면 항상 application context 를 참조할 수 있을까? 메모리 누수에 대해 걱정할 필요가 없나? 답은 서두에서 언급한바와 같이 Context 는 항상 똑같지 않다는 것이다.\n\n\n### Context Capabilities\n\n\n안전하게 Context 객체를 처리하는 방법은 context 가 어디에서 왔는지에 달렸다.\n아래표를 보면 application 이 Context 를 받을 때의 일반적인 위치를 알 수 있다. \n\n|                         |Application| Activity\t| Service\t| ContentProvider\t| BroadcastReceiver|\n|-------------------------|-----------|-------------|-----------|-------------------|------------------|\n|Show a Dialog \t\t\t\t|\tNO\t\t|YES\t\t|NO\t\t\t|NO\t\t\t\t\t| NO               |\n|Start an Activity \t\t\t|\tNO<sup>1</sup>\t|YES\t\t|NO<sup>1</sup>\t\t|NO<sup>1</sup>\t\t\t\t| NO<sup>1</sup>|\n|Layout Inflation \t\t\t|\tNO<sup>2</sup>\t|YES\t\t|NO<sup>2</sup>\t\t|NO<sup>2</sup>\t\t\t\t| NO<sup>2</sup>|\n|Start a Service \t\t\t|\tYES\t\t|YES\t\t|YES\t\t|YES\t\t\t\t| YES|\n|Bind to a Service \t\t\t|\tYES\t\t|YES\t\t|YES\t\t|YES\t\t\t\t| NO|\n|Send a Broadcast \t\t\t|\tYES\t\t|YES\t\t|YES\t\t|YES\t\t\t\t| YES|\n|Register BroadcastReceiver  |\tYES\t\t|YES\t\t|YES\t\t|YES\t\t\t\t| NO<sup>3</sup>|\n|Load Resource Values\t\t|   YES\t\t|YES\t\t|YES\t\t|YES\t\t\t\t| YES|\n\n1. Application 이 여기에서 Activity 를 시작할 수는 있다. 그러나 새 task 생성 필요. 특정 상황에서만 해당됨, 하지만 application 에서 편법으로 back stack 동작을 만들 수 있지만 추천하지는 않고 다른 방법을 찾기를 권장한다\n2. 가능은 하지만 inflate 가 application 에 정의된 것이 아닌 시스템 기본 테마을 기반으로 이루어짐\n3. Android 4.2 이상에서 receiver 가 sticky broadcast 의 현재 값을 얻을 때 사용된 뒤 null 일때 가능 \n\n\n\n### User Interface\n\n앞서 나온 표에서 확인한 바와 같이 모든 context가 똑같이 처리될 수는 없다. 이는 UI와 밀접한 관련이 있다. 실제로 UI와 관련된 모든 작업을 처리할 수 있는 것은 Activity이다. 다른 instance는 모든 카테고리에서 비슷하다.\n\n다행히 이 세 가지 동작은 application 이 activity 의 범위 밖에서는 실제로 할 수 있는 것이 없다는 것을 의미한다. 이는 framework 디자인의 목표와 비슷하다.\napplication context 를 참조하는 dialog 를 만들었을 때 혹은 application context 에서 activity 를 시작하면 exception 을 던지고 crash 된다. 잘못된 동작이라는 뜻이다.\n\n또 다른 문제는 layout 을 inflate 할 때 발생한다. 마지막 layout 조각의 inflation 을 읽을 때, 알 수 없는 프로세스가 숨겨진 동작을 하는 것을 이미 알고 있을 것이다. 올바른 context 사용이 이런 동작과 연관되어 있다. 프레임워크에서는 application context 에서 LayoutInflater 가  완벽하게 view hierarchy 를 만들어내고 에러를 출력하지는 않지만 프로세스는 앱에서 정의된 테마나 스타일을 고려하지 않는다. __이는 Activity 가 manifest 에서 정의된 테마를 사용하는 유일한 Context 이기 때문이다. Context 를 잘못 사용하게 되면 시스템 기본 테마를 사용하는 instance 가 만들어지고 기대했던 것과 다르게 출력된다.__\n\n\n### The Intersection of these Rules (다른 관점) \n\n필연적으로 두가지 룰이 출동된다는 결론에 도달할 것이다. long-term reference 가 저장되어야 하는 application 이 있고 UI의 동작 때문에 저장되어야 하는 Activity 가 있다. 만약 그렇다면 이는 framework 가 의도하는 정석적인 디자인이 아니기 때문에 다시 설계하기를 추천한다.\n\n### The Rule of Thumb (경험에서 나온 결정)\n \n__대부분의 경우 작업하고 있는 component에 있는 Context를 사용하자 그러면 component의 lifecycle 안에서 Context를 안전하게 참조할 수 있다. Activity 나 Service 밖에 있는 객체의 context 의 참조를 저장하는 경우, 일시적으로라도 해당 참조를 application context로 바꾸길 추천한다.__\n\n","fields":{"slug":"/2019_11_05_android_context/"},"frontmatter":{"title":"[번역] Context? 무슨 Context?","published":true}}},{"node":{"rawMarkdownBody":"\n원본:  https://writing.pupius.co.uk/whiteboarding-4df873dbba2e\n\n# Whiteboarding\n\n만약 당신이 개발자 면접을 본다고 하면 화이트보드에 코딩하는 것을 피하기는 어려울 것이다. 이러한 관행에 대한 비판은 있지만 구글, 페이스북, MS, 아마존 같은 큰 기업들이 사용하고 있는 방법이다.\n\n이 포스팅에서는 이러한 인터뷰 방식이 옳은지에 대한 언급은 하지 않겠다.(나는 이 방법이 면접자들이 문제를 해결하는 능력을 볼 수 있는 좋은 방법이라고 생각한다.) 하지만 테크기업들이 인터뷰하는 방식이라는 점에서 피할 수 있는 몇가지 일반적인 함정에 대해서 얘기해보겠다.\n\n## 배경\n이야기에 앞서, 나는 6년간 구글에서 일했고 200번의 면접을 했다. 구글 면접은 어렵기로 악명이 높으며, 면접 피드백에 코드가 없으면 채용위원회에서 면접관에게 연락한다. \n\n나는 가치있는 업적을 이룬 사람들을 인터뷰했다. 그리고 또한 자격을 갖추지 못한 사람들도 인터뷰했다. 항상 가장 힘든 유형은 그 중간 어디쯤에 있는 사람들을 평가하는 것이다.\n\n그리고 올해 초 나는 직업을 바꾸고 몇몇 실리콘밸리의 기업이나 스타트업에서 면접을 보았다. 그래서 채용과정의 대상이 될 기회도 갖게 되었다.\n\n기술회사들은 채용의 false-postiive 를 피하기 위해 적당한 지원자를 채용을 하지 않는 실수를 하게 되는 것을 감수한다.  \n\n## 침착하라\n침착하고, 냉정하고 가능한 깔끔하게 쓰도록 노력해라. 당신의 집중력에 도움이 될 것이고 면접관이 코드를 이해하는데 도움이 될 것이다.\n\n## 질문하라\n대부분 면접 질문들은 의도적으로 모호하다. 면접관은 명확하지 않은 문제에 대해 어떻게 다루고 가정하는지 보고 싶어한다. 알고리즘을 구현한다면 제약사항이 무엇인가? 메모리? 실행시간? 입력크기? 기타 등등\n\n질문에 답하면서 당신이 무얼 하고 있는지 생각의 과정은 어떤지 알 수 있게 얘기하라. 면접의 목적은 정답도 있지만 정답만큼이나 당신이 어떻게 정답을 이끌어내는지의 과정을 보는 것이다. \n\n## Code how you’d normally code\n내가 봤던 가장 일반적인 실수는 면접자들이 그들 정답에서 길을 잃어버리는 것이다. 실제상황에서 50라인 이상의 함수를 쓰기 않기를 바라며 면접에서 그러지 마라. 복사, 붙여넣기를 쓸 수 없고, 면접의 긴장속에서 흐름을 놓치기 쉽다. \n\n## Check your work\n\n끝났다고 생각이 들면, 했던 것을 체크하라.\n\n대부분의 에러가 마무리 단계에서 일어난다. 좋은 방법은 몇가지 샘플 입력을 돌려보는 것이다. 케이스 하나를 놓치거나 에러 하나를 발견해도 걱정하지 마라 면접관은 이를 고치기 위해 드는 시간을 아까워 하지 않는다. \n\n그리고 엣지케이스나 일반적이지 않은 입력에 대해서도 체크하라. 유닛테스트를 어떻게 할 것인지 생각해보고 적어봐라.\n\n## Practice\n인터뷰를 준비할 때 알고리즘을 다시 살펴보고 최신 기술과 모범사례를 읽어볼 것이다. 이런 코드를 손으로 직접 적어보는 것을 추천한다. \n\nJQuery helper 나 메서드를 가장 잘하는 언어의 표준 라이브러리로 구현해보는 것을 생각해보라. manhole cover에 대해서 언급하는 사이트를 무시하는 샘플 문제를 검색해보라 (역: 이 문장은 무슨 뜻인지 모르겠음)\n\n자기 자신이 준비가 되었다고 생각하면, 코드가 실제로 동작하는지 실행해보라. 동작하지 않으면 다시 학습하라.\n\n## Research\n아마도 당신은 면접을 보는 회사에서 일하고 싶어할 것이다. 그러니 그들이 하는 일에 관심을 갖고 열정적으로 보이도록 노력하라.\n\n당신은 의심의 여지없이 그 회사의 제품에 대한 질문을 받을 것이고 \"왜 여기에서 일하고 싶나?\" 라는 질문도 받을 것이다. 좋은 대답을 하기는 힘들겠지만 회사에 대한 조사와 질문에 대한 대답을 준비하라.\n\n## Have fun\n\n무엇보다, 즐기려고 하라. 호기심을 갖고 도전하라. 당신은 이러한 과정에서 더 많은 것을 얻을 것이고 더 잘 알게 될것이다. 면접에서는 당신이 능력이 있는지 보는 것 뿐만 아니라 당신과 같이 일하고 싶은지도 같이 보고 있다.\n\n이러한 것이 명백하고 단순할수도 있다. 그리고 면접자의 가능성에 영향을 미치는 것이 부당하다고 느껴질 수도 있다. 하지만 전혀 코딩을 못하는 사람과 화이트보드에서만 코딩을 못하는 사람을 구분해내기는 어렵다. 그러니 최선을 다해 자신에게 유리한 점을 돋보이게하고 화이트보드가 방해가 되지 않도록하라. \n","fields":{"slug":"/2019_11_02_whiteboarding/"},"frontmatter":{"title":"[번역] Whiteboarding","published":true}}},{"node":{"rawMarkdownBody":"\n\n원문 : https://medium.com/@programmerr47/singletons-in-android-63ddf972a7e7\n\n싱글톤패턴에 대한 글과 또 그 해악에 관한 논란은 많다. <br>\n모든 글이 특정한 작은 문제에 대해 언급한다. 메모리 누수나 멀티 프로세싱에 관한. 하지만 모든 주제를 다루는 글은 찾지 못했다. 그래서 이 글에서 모든 이슈 혹은 대부분의 이슈 대해 다뤄본다.  \n그리고 나의 안드로이드, 자바, 프로그래밍에 관한 지식으로 최선을 다해 이 글을 작성해보았기 때문에 독자뿐만 아니라 나에게도 큰 도움이 되었다. \n\n## So, what if I have simple Singleton (싱글톤이란 무엇인가)\n\n아래의 코드를 보자\n\n```java\npublic class CarelessSingleton{\n    public static final CarelessSingleton instance = new CarelessSingleton();\nprivate Object someState;\n    \n    private CarelessSingleton() {} \n    public void setState(Object state) {\n        this.someState = state;\n    }\n    public Object getState() {\n        return someState;\n    }\n}\n```\n\n‘lazy initialisation’와 ‘multithreading’ 측면을 제외해도 두가지 문제점이 있다.\n\n모든 곳에서 변경가능한 싱글톤을 생성하였다. 이는 안드로이드문제가 아닌 아키텍쳐문제로 볼 수 있다. 물론 \"어디서 값을 수정하는지 알고 있다.\" \"고작 두군데 밖에 없다\" 등등으로 얘기할 수 있다. 하지만 여전히 싱글톤은 글로벌 변수를 다루고 있다. 게다가 두번째 세번째 인스턴스를 만들 수 없고 하나의 인스턴스만 있다. \n\nlosing state 문제, 싱글톤에서 다루는 state 가 application 에서 바뀔 수도 있음\n안드로이드에서는 수정가능한 싱글톤이 더 문제가 될 수 있는게 state safe 하지 않다는 것이다. 싱글톤이 어플리케이션에서 바꿀 수 있는 state를 생성한다면 쉽게 state를 잃어버리게 된다.\n\n\n간단한 어플리케이션을 예로 들어보자. 레이아웃 파일을 보면\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<FrameLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <TextView\n        android:id=\"@+id/test_text\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center\"\n        android:text=\"0\"/>\n    <Button\n        android:id=\"@+id/test_button\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"bottom|center_horizontal\"\n        android:layout_marginBottom=\"16dp\"\n        android:text=\"Set global 5\" />\n</FrameLayout>\n```\n\n그리고 activity:\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    private TextView textView;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        textView = (TextView) findViewById(R.id.test_text);\n        displayState();\n        findViewById(R.id.test_button)\n            .setOnClickListener(new View.OnClickListener() \n                @Override\n                public void onClick(View view) {\n                    CarelessSingleton.instance.setState(5);\n                    displayState();\n                }\n            });\n    }\n    private void displayState() {\n        Object state = CarelessSingleton.instance.getState();\n        textView.setText(String.valueOf(state));\n    }\n}\n```\n\n스크린 중앙에는 0 이 뜰것이고 버튼을 클릭하면 5가 될것이다. 앱을 회전시킬 수도 있다. 혹은 홈버튼을 누르고 앱아이콘을 실행할 수 있다. 모든게 일반적인 동작이다. 여전히 화면가운데에 5가 있다. 하지만 다른 앱을 실행하면 어떨까? 게임을 플레이한다든가 이메일을 쓴다든가 하고 다시 앱으로 돌아오면? 5 대신 0이 떠있나?\n\n## 문제점\n기기를 사용하는 동안 시스템은 메모리 사용때문에 일정시간 이상 사용되지 않은 앱을 kill 한다. 그리고 다시 앱으로 돌아오면 시스텝에서 새로 실행을 하게 되고 상태를 다시 불러온다. 물론 싱글톤은 저장되지 않고 다시 불러오지도 않는다. 왜냐하면 kill 될 수 있는지 알 수 없으니깐\n\n\n## 솔루션\n\n확실한 해결책은 없어 보인다. 모든 Activity, Fragment, Service 에서 싱글톤은 바뀔 수 있으니. 저장하는 방법으로 해결할 수 있어보인다. 간단한 해결책 두개가 있는데 완벽하지 않다. 미리 말해두지만 이러한 싱글톤 문제의 해결책은 아키텍쳐의 문제 때문에 완벽하지 않다.\n\n\n첫번째 꼼수는 싱글톤에서 onSaveInstanceState 와 비슷하게 savestate ( Bundle state ) / restorestate(Bundle state) 를 사용하는 방법\n\n```java\npublic void saveState(Bundle state) {\n    state.putInt(SINGLETON_STATE, getState());\n}\npublic void restoreState(Bundle state) {\n    setState(state.getInt(SINGLETON_STATE));\n}\n```\n\n하지만 이러한 접근은 큰 단점이 있다. 어디서 state 를 저장할지를 정해야한다는 것이다. 사실 activity, view, fragment 들 중 결정할 수 있다. 예를 들어 싱글톤 state 를 activity 에서 변경하고 종료했다고 치면 백그라운드 서비스에서 한번이상 state 를 변경할수도 있다. 그러고 나서 앱이 시스템에 의해 종료되고 재시작하면 싱글톤의 마지막 state 는 불러올 수 없게 된다. 그리고 당연히 state 를 저장하고 불러오는 많은 양의 boilerplate 코드를 모든 activity, view, fragment 등등에 작성해야한다. \n\n이 방법의 조금 개선된 버젼 : bundle 말고 다른 방법으로 싱글톤의 state 를 저장한다. 예를 들어 SharedPreferences, Stream 혹은 클래스나 인터페이스 등. 그렇게 되면 파라미터 없는 메서드를 만들 수 있고 싱글톤이 스스로 저장하는 로직을 가진다. 따라서 save/restore 를 모든 곳에서 할 있다. 하지만 역시 boilerplate 코드가 많아진다.\n\n\n두번째 꼼수. 싱글톤 setSate 에 저장기능을 넣어서 자동저장되게 할 수 있다. 싱글톤 초기화 'restore' 에서 자동으로 로드될것이다.\n\n첫번째 꼼수와는 다르게 많은 코드가 생기는것을 막아준다. 하지만 영구적으로 저장되는 단점이 있다. 예를들어 setState 가 루프안에서 돌면 성능저하가 일어난다.\n\n클라이언트에서 자동저장 기능을 키거나 끄는 식으로 두가지 방법을 섞어 쓸 수 있다. \n\n## 우리가 알게 된 것\n\n위의 예는 naive 한 방법으로 제대로 관리하지 않으면 싱글톤이 제대로 동작하지 않을 수 있다. 싱글톤은 항상 여기저기에서 쓸 수 있고 저장할 필요가 있다는것을 명심하라.\n\n\n## Context를 저장하는 싱글톤\n\n\n아래의 코드를 보면:\n\n```java\npublic class ContextSingleton {\n    private static ContextSingleton instance;\n    \n    public static void init(Context context) {\n        if (instance == null) {\n            instance = new ContextSingleton(context);\n        }\n    }\n    \n    public static ContextSingleton getInstance() {\n        return instance;\n    }\n    \n    private final Context context;\n    \n    private ContextSingleton(Context context) {\n        this.context = context;\n    }\n    \n    public Context getContext() {\n        return context;\n    }\n}\n```\n\n\"이 코드에 무슨 문제가 있지?\"라고 생각할 수도 있다. \"변경 불가능한 인스턴스가 있는데 문제가 없지 않을까?\" \n\n멀티쓰레딩 환경은 일단 생각하지말자. activity 가 실행될때 ContextSingleton.init(this) 을 통해 싱글톤을 초기화 한다. 그리고 두번째 activity 가 실행되고 세번째 activity 실행되고 네번째 ... 반복되면 메모리가 고갈된다. \n\n\n## 문제점\n\n안드로이드에서는 service, 리소스 혹은 파일 등에 접근할때 사용되는 Context 라는 클래스가 사용된다. 그래서 Context 를 사용하는 싱글톤 객체가 매우 유용하게 보인다. \n\n하지만 이는 함정이다. 물론 많은 라이브러리에서 Context를 레퍼런스하는 싱글톤을 제공하고 있다. 허나 이는 application context 이다. local context 가 아니라는 점\n\nApplication context 와 Activity context 는 둘다 Context 클래스의 instance 이다. 하지만 Application context 는 application lifecycle 을 따르고 acitivity context 는 activity lifecycle을 따른다. Application context 는 어플리케이션이 종료될때 destroy 되고 activity context 는 activity 가 종료될때 destroy 된다.\n\n싱글톤은 어플리케이션 전체에 존재한다. 그래서 어플리케이션이 종료될때 종료된다. 만약 싱글톤안에 있는 Acitivity context가 다른 acitivity 에서 실행되고 어플리케이션이 종료된다면 괜찮겠지만 두번째 Acitivity 에서 메모리를 많이 쓴다면 시스템은 첫번째 acitivity 를 종료시키려 할 것이다. 하지만 싱글톤의 레퍼런스를 가지고 있어서 실패할 것이다. 그리고 OOM exception 을 받게 될 것이다. \n\n\n## 솔루션\n\n요약하자면 app context 를 제외한 context 를 싱글톤에 넣지마라 그리고 다음과 같이 초기화 코드를 변경하는 것을 추천한다.\n\n```java\npublic static void init(Context context) {\n    if (instance == null) {\n        context = context.getApplicationContext();\n        instance = new ContextSingleton(context);\n    }\t\n}\n```\n\n좀 더 설명하자면 원한다면 이 싱글톤에 activity context 를 넘길 수 있다. 하지만 acitivity 가 종료되거나 다른 activity 로 바꾸거나 새로운 activity 를 시작하면 레퍼런스를 정리할 필요가 있다는 걸 명심하라. 골치아픈 일이기 때문에 싱글톤으로 context 를 넘기지 않는 것을 강력하게 추천한다. 하지면 굳이 context를 싱글톤으로 넘기길 원한다면 application context 를 넘겨라. 만약 local context 를 넘겨야한다는 것을 100% 확신한다면 (예를들어 백그라운드로 비트맵 연산을 해서 view 에 출력을 해야할 때) GC 가 동작할 수 있게 WeakReference 를 사용하라\n\n\n## 배우게 된 것들\n\n싱글톤에 context 를 넘길 때 두번 생각하라. 올바르게 context 를 사용하고 있는지 확신이 필요하다. local context 를 사용할 거면 메모리 누수를 방지하기위해 객체의 사용이 끝나고 GC 가 수집할 수 있도록 release reference 하는 코드를 추가하라\n\n## 싱글톤을 Activity나 Remote Servcie 안에서 사용하고 싶을 때\n\nactivity, fragment, UI component 등은 application 프로세스안에 있기 때문에 안된다. Remote Service 는 remote 프로세스 안에 있기 때문에 안된다. AIDL를 사용하는 수 밖에 없다.(IPC 통신)\n\n예를들어 activity 끼리나 local service 에서는 global static state 를 만들고 공유할 수 있다. ( 나쁜예, 하지만 싱글톤에서 자주 일어난다.) 각각의 프로세스들이 각각의 클래스 로더를 가지고 있기 때문에 activity 나 remote service 에서는 그럴 수 없다. \n\n이 경우 두개의 싱글톤 instance 를 가진다. 하나는 application 하나는 remote process.\n\n## 솔루션\n\n프로세스간에 싱글톤을 쓰고 싶다면 제발 싱글톤 잊어버리고 AIDL, broadcast, intent 등을 사용하라. 멀티프로세싱에서 사용되는 싱글톤이란 없다. 싱글톤은 싱글프로세스에서 실행되는 것이다.  remote process 와 싱글톤이 앱에 있다면 하나의 프로세스에서 사용하라\n\n## immutable singleton 의 경우\n\n바꿀 수 없는 싱글톤(제약사항과 함께)은 안드로이드에서 싱글 인스턴스를 만들기 위한 적절한 옵션이다. 왜냐하면 instance 를 한번 생성해서 바뀌지 않기 때문이다. 앱을 다시 시작해도 마찬가지\n\n물론, 몇몇의 문제에 대해서는 좋은 해결방법이지만 앞에서 언급했듯이 immutable 싱글톤에 local context 를 넘겨준다면 망한다. \n\nImmutable Singletons 의 좋은 사용방법은 Enumeration 이라는 ‘extension’ 을 붙이는 것이다.  Enums 은 미리 정의된 인스턴스의 숫자, 하지만 싱글톤과는 다르게 클래스에서 2, 3, 10 개의 인스턴스가 될 수 있다. 예를들어\n\n```java\npublic static final String CONST_1 = “const 1”;\npublic static final String CONST_2 = “const 2”;\npublic static final String CONST_3 = “const 3”;\n```\n\nstatic final 로 상수선언하는 것 대신에 이렇게 정의할 수 있다.\n\n```java\npublic enum CONSTANTS {\n    CONST_1, CONST_2, CONST_3\n}\n```\n\n이런 접근은 타입정의된 상수값을 얻을 수 있고 다른 곳에서 사용할 때 유효성 검사를 생략할 수 있다.\n\n### 문제점\n\n사실 성능이슈나 메모리 이슈가 크게 문제되지는 않는다. 하지만 구조적인 문제가 있다. 만약 immutable singleton 이 있다면 반드시 필요한 것인지 다시 생각해보자.\n\n### 솔루션\n\n세가지 타입의 immutable singleton 을 떠올릴 수 있다.\n\n\n1. state 없고 함수만 있는 싱글톤. 사용할 때 Something.INSTANCE.computeSomething(SomethingOther other)’ 이런 식으로 사용하게 된다. 이런 경우 싱글톤이 아닌 빈생성자와 static 메서드만 있는 ‘Utility’ 클래스 같은 것으로 바꾸길 권한다. 그래서 ‘SomeUtil.computeSomething(SomethingOther other)’ 형식으로 사용하게 되면 'INSTANCE' 라는 단어를 줄일 수 있다. 그리고 'SomethingOther' 클래스가 라이브러리 클래스가 아니고 직접 작성한 클래스라면 그냥 ‘other.computeSomething()’ 로 사용할 수 있게 'computeSomething’ 메서드를 그 클래스 안에 작성하는 것을 고려해 보는것도 좋다. \n\n2. 초기 state ( context 말고) 와 함수로 이루어진 싱글톤. 마찬가지로 private 생성자에 있는 초기 state 와 static 메서드로 이루어진 ‘Utility’ 클래스로 대체될 수 있다. \n\n3. applicate context 와 함수로 이루어진 싱글톤. 앱과 상호작용하는 라이브러리에서 많이 등장한다. 앱에서 비슷한걸 사용하고 싶으면 생성자가 있는 클래스(싱글톤이 아닌)를 만들어 application context 를 생성자 파라미터로 넣고 이를 Application의 onCreate 에서 호출하는 것을 고려하라. 그래서 Application 클래스의 static 필드에 저장하고 static getter 등으로 접근할 수 있게 ( 아래에서 상세히 설명 예정)\n\n\n## 싱글톤 올바르게 쓰는법\n\n이 글의 의도는 이미 나와있다. 싱글톤 쓰지마라\n\n\n1. 전역 state 사용한다. OOP에 맞지 않다.\n\n2. state를 잃어버릴 수 있다.\n\n3. context 누수가 생길 수 있다.\n\n4. test 하기 힘듬 ( init state 를 불러오거나 지우는 stateful 싱글톤이 필요)\n\n5. 멀티프로세싱앱에서는 싱글톤이 싱글톤이 아님\n\n6. 어디서나 실행가능해서 유지보수하기 힘들다.\n\n7. 멀티쓰레드 환경에서 예상못한 동작\n\n8. 확장성 부족\n\n지금부터 싱글톤 쓰지 않겠다. 전역 state 가 필요하면 single instance 를 쓸 것이다. single instance 개념은 싱글톤이랑 다르다. single instance 는 전역 state 를 제공하기 위해 만들어진다.( OOP 에서 일반적이지 않지만 Android 에서는 일반적이다) 하지만 여전히 클래스에서는 여러개의 instance 를 만들 수 있다. 그래서 클래스를 테스트하거나 자잘한 작업들을 처리하기 위한 local instance를 만들기 좋다. 또한 로직을 확장하는 것도\n\n\n클래스의 전역 instance 를 만들기 위해 application class 를 상속받고 onCreate 메서드에서 초기화 시켜준다. 이제 global instance 의 static getter 를 사용할 수 있다.\n\n```java\npublic class MyApplication extends Application {\n    private static Something something;\n\n    public void onCreate() {\n        super.onCreate();\n        something = new Something();/new Something(getApplicationContext())/new Something(InitState state);\n    }\n\n    public static Something getSomething() {\n        return something.\n    }\n\n}\n```\n\n\n‘getSomething()’ 을 호출해서 global instance 에 접근할 수 있다. \n\n## 결론\n\n싱글톤은 나쁘고 사용을 피해야한다. 특히 안드로이드에서는 정말 글로별 변수가 필요하다면 application 생성할 때 global instance 를 만들어서 사용하는 것이 좋다.\n\n## further works\n[Working with permissions in Android](\nhttps://medium.com/@programmerr47/working-with-permissions-in-android-bbba823be785)\n\n[Save state with Delegates](\nhttps://medium.com/@programmerr47/save-state-with-delegates-d3c7d3a6a474)\n\n[Refactor your BaseFragment class](\nhttps://medium.com/@programmerr47/refactor-your-basefragment-class-d6f721decc85)\n\n","fields":{"slug":"/singleton_in_android/"},"frontmatter":{"title":"[번역] Singleton in Android","published":true}}},{"node":{"rawMarkdownBody":"\n이 글은 \n[원문 : https://thenoisychannel.com/2011/08/08/retiring-a-great-interview-problem](https://thenoisychannel.com/2011/08/08/retiring-a-great-interview-problem) 의 글을 의역 및 정리한 것이다. \n\n## 서론\n\n인터뷰를 하는데에 만능해결책이 있는건 아니다. IQ 테스트와 같은 방법은 개발자를 채용하는데 좋은 방법이 아니다. 기껏해야 하나의 능력에 대한 테스트밖에 안된다. 최악의 경우 후보자가 비슷한 문제를 본적이 있는지 혹은 통찰력이 있는지에 대한 헛수고밖에 안된다. 코딩 문제는 평가하는제 더 좋은 방법이긴 하지만 전통적인 인터뷰는 ( 전화상이 됐든 온사이트가 됐든) 차선의 방법일 뿐이다. 물론 코딩문제가 문제 해결력이나 해결방법을 코드로 바꾸는 능력을 평가할 수 있는것도 아니다.\n\n이러한 문제점을 보완하기위해 몇년동안 Endeca, Google, LinkedIn 에서 해왔던 방법들을 소개하겠다. 일단 그 문제들을 설명하고 포스트의 끝에 왜 그것이 효과적이었는지 설명하겠다.\n\n\n## 문제\n\n\"word break\" 문제라고 칭하겠다.\n\ninput string 과 dictionary 가 주어지고\ndictionary 에 있는 단어들을 공백으로 구분하여라\n예를들어 \"applepie\" 와 dictionary 가 주어지면 \"apple pie\" 로 출력하라\n\n일부러 이 문제에 대한 조건을 모호하거나 적게 제시해서 후보자에게 질문할 수 있는 기회를 줬다.\n\n\n\nQ: 만약 입력 string 이 이미 dictionary 에 있는 단어면 어떻게 되나? </br>\nA: single word 는 예외 케이스이다.  \n\nQ: 단어가 두개라고 가정해도 되나? </br>\nA: 안된다. 하지만 그렇게 시작하면 더 쉬울것이다.\n\nQ: dictionary 에 없으면 어떻게 하나 </br>\nA: null 을 리턴하거나 비슷하게 처리하라\n\nQ: 비슷한 단어나 스펠체크도 해야하나 </br>\nA: 정확하기 dictionary 에 있는 단어만 고려하라\n\nQ: 정답이 여러개이면 어떻게 하나 </br>\nA: 하나만 출력하라\n\nQ: trie, suffix tree, Fibonacci heap 등을 생각하고 있다. </br>\nA: dictionary 를 구현할 필요는 없다. 그냥 적절한 구현을 생각해보라\n\nQ: dictionary 에서 제공되는 명령어가 있나? </br>\nA: string 읽기만 제공한다.\n\nQ: dictionary 의 크기는 얼마나 큰가? </br>\nA: input string 보다는 훨씬 크다고 가정하라. 하지만 메모리는 충분하다.\n\n후보자가 어떻게 문제의 조건을 설정하는지 보면 후보자의 자료구조와 알고리즘에 대한 이해뿐만이 아니라 커뮤니케이션 스킬과 디테일에 대한 태도를 볼 수 있다. \n\n## A FizzBuzz Solution\n\n문제의 조건이 정해지고 문제 풀이로 넘어가면. 어떤 후보자들은 input string 을 두 단어로 가정하고 간단한 알고리즘을 작성한다. 나는 이걸 FizzBuzz 문제라 부르고, 유능한 소프트웨어 엔지니어라면 그들이 쓸 수 있는 언어를 사용해서 아래와 같은 코드를 작성할 수 있을 것으로 기대한다.\n\n(Fizz-Buzz 문제 : \n1 부터 100 까지 출력하는 프로그램을 만든다. 3의 배수에는 \"Fizz\"를 출력한다. 5의 배수에는 \"Buzz\" 를 출력한다.  3과 5의 공배수인 숫자에는 \"FizzBuzz\" 를 출력한다.\n대부분의 좋은 프로그래머들은 몇분안에 코드를 작성할 수 있어야 한다. 그런데 대부분의 학부 졸업생들은 못한다. senior 개발자들도 10~15분 이상걸리는 걸 봤다.)\n\n자바코드\n```java\nString SegmentString(String input, Set<String> dict) {\n  int len = input.length();\n  for (int i = 1; i < len; i++) {\n    String prefix = input.substring(0, i);\n    if (dict.contains(prefix)) {\n      String suffix = input.substring(i, len);\n      if (dict.contains(suffix)) {\n        return prefix + \" \" + suffix;\n      }\n    }\n  }\n  return null;\n}\n```\n\n나는 위와 같은 코드도 작성하지 못하는 지원자들을 인터뷰한 적이 있다. (구글 전화인터뷰를 통과한 사람을 포함해서). Jeff Atwood 가 말한대로 FizzBuzz 문제는 프로그램 못하는 지원자들을 인터뷰하는데 낭비하는 시간을 막아줄 수 있다.\n\n\n## A General Solution (일반적인 방법)\n\n물론 좀더 흥미로운 문제는 input string 의 word 갯수가 몇개가 되도 상관없는 경우이다. 많은 방법이 있지만 가장 정석적인 방법은 recursive backtracking 이다. 다음과 같다.\n\n```java\nString SegmentString(String input, Set<String> dict) {\n  if (dict.contains(input)) return input;\n  int len = input.length();\n  for (int i = 1; i < len; i++) {\n    String prefix = input.substring(0, i);\n    if (dict.contains(prefix)) {\n      String suffix = input.substring(i, len);\n      String segSuffix = SegmentString(suffix, dict);\n      if (segSuffix != null) {\n        return prefix + \" \" + segSuffix;\n      }\n    }\n  }\n  return null;\n}\n```\n\n많은 소프트웨어 엔지니어 후보자들이 위와 같은 코드 혹은 비슷한 (스택을 사용한다든가) 코드를 30분안에 작성하지 못한다. 그들 중 많은 수가 유능하다고 생각은 하지만 머신러닝이나 대규모 검색 기능을 만드는 회사에 그들을 고용하지는 않을 것이다.\n\n\n## Analyzing the Running Time (실행시간 분석)\n\n후보자가 위와 같은 코드를 작성했다고 해도 아직 남은 것이다. input 크기 n 에 대한 Worst case bigO notation 을 물어봐야 한다. 후보자들은 O(n) 혹은 O(n!) 등의 답을 얘기한다.\n\n그 때 난 다음과 같은 힌트를 준다.\n\n\"a\", \"aa\", \"aaa\", ..., i.e., 같이 글자 'a' 로 구성되어 있는 dictionary 라고 가정해보라 input string n-1 번째에서 'b' 다음에 'a' 가 온다면 어떻게 되는가?\n\nHopefully the candidate can figure out that the recursive backtracking solution will explore every possible segmentation of this input string, which reduces the analysis to determine the number of possible segmentations. I leave it as an exercise to the reader (with this hint) to determine that this number is O(2n).\n\n후보자가 recursive backtracking solution 이 모든 가능한 segmentation 을 탐색하여 O(2<sup>n</sup>) 이 된다는 힌트를 남기고 풀이는 독자들의 숙제로 남기겠다. (hint : powerset 에 대한 개념, 멱집합 : 집합의 모든 부분집합의 집합)\n\n## An Efficient Solution (효율적인 방법)\n\n\n후보자가 여기까지 왔다면 O(2<sup>n</sup>) 보다 좋은 방법이 있는지 물어볼 것이다. 그럼 대부분은 이것이 순서가 있는 문제라고 알아차린다. 그리고 똑똑한 사람은 DP 나 memoization 을 적용할 방법을 찾게 된다. \n\n```java\nMap<String, String> memoized;\n\nString SegmentString(String input, Set<String> dict) {\n  if (dict.contains(input)) return input;\n  if (memoized.containsKey(input) {\n    return memoized.get(input);\n  }\n  int len = input.length();\n  for (int i = 1; i < len; i++) {\n    String prefix = input.substring(0, i);\n    if (dict.contains(prefix)) {\n      String suffix = input.substring(i, len);\n      String segSuffix = SegmentString(suffix, dict);\n      if (segSuffix != null) {\n        memoized.put(input, prefix + \" \" + segSuffix);\n        return prefix + \" \" + segSuffix;\n\t\t}\n\t}\n\tmemoized.put(input, null);\n\treturn null;\n}\n```\n\n\n마찬가지로 후보자는 worst-case 분석이 가능해야한다. 요점은 SegmentString 이 input string 에 따라 불린다는것 그리고 그 땐 O(n) 가 나온다는 것이다. 위와 같은 경우 substring 연산이 일정하다는 가정하에 O(n<sup>2</sup>) 가 나온다는 것을 결과로 남기고 풀이는 독자에게 맡기겠다. \n\n\n## Why I Love This Problem (이 문제를 좋아하는 이유)\n\n이 문제를 좋아하는 이유는 여러가지가 있다. 몇가지를 나열하자면\n\n- 실제로 소프트웨어를 개발하다보면 나올 수 있는 문제이다. \n\n- 특화된 지식이 필요없는 문제이다. string, set, maps, recursion, dp 나 memoixation 의 간단한 응용. 학부생의 지식으로 커버할 수 있는 것들이다. \n\n- 코드가 45분간의 면접시간에 사용할 수 있을 만큼 짧지만 깊이가 있다. 특별한 도구가 필요하지 않다.\n\n- \b도전적인 문제이다. 하지만 운으로 풀 수 있는 문제가 아니다. 게다가 문제에 대한 분석과 CS 기본지식의 응용이 요구된다. \n\n- 문제를 해결하는 후보자의 능력이 모아니면 도가 아니다. 최악의 후보자는 fizzbuzz 문제도 45분동안 풀 수 없다. 문제를 좀 더 어렵게 내도 최적의 정답은 10분이면 도출 가능하다. e.g.) dictionary 가 아주 크면 메모리에서 어떻게 다룰 것인가? 대부분의 후보자는 어떻게든 해결책을 만들어 낸다. \n\n\n## Happy Retirement \n\n불행하게도, 이 좋은 문제도 이제 유행이 지났다. Glassdoor 에 누가 이 문제를 포스팅한 것을 발견했다. \n\n면접용 좋은 문제를 찾는 것은 어렵다 그리고 비밀유지하기도 어렵다. 이상적인 면접 질문은 한정된 개념를 개선하는 것이다. 난 동료들고 이러한 접근으로 일하고 있다. \n\n그 동안 word break 문제를 경험한 모두에게 도움이 되길 바란다. 어떤 문제도 완벽하지 않으며 어떠한 문제도 후보자가 적합한지에 대한 완벽한 척도가 될 수는 없다. 그래도 이 문제는 꽤 쓸만하고 많은 사람이 놓칠 수 있을만한 것이다. \n\n\n","fields":{"slug":"/retiring_great_interview_problem/"},"frontmatter":{"title":"[번역] 훌륭한 인터뷰 문제를 떠나보내며","published":true}}},{"node":{"rawMarkdownBody":"\nABC: Always Be Coding\n\n원문 : https://medium.com/always-be-coding/abc-always-be-coding-d5f8051afce2\n\n\n## Technical Tips\n\n1. ABC (Always Be Coding). 간단히 말해. 코드를 작성함으로써 연습이 된다. 최선의 연습은 연습에 집중하는 것이다. 목표를 가져라, 새로운 영역을 찾아 도전하라. 시간이 지나면 만들어진 포트폴리오가 생기고 자신만의 프로젝트가 생길 것이다. 깃허브는 포트폴리오를 보여주기에 좋은 공간이다.    \n2. 적어도 한가지 이상의 언어를 마스터하라. 언어하나를 마스터하는 것은 좋은 센스와 관점을 갖게 한다. 이를 위해서는 정말 많은 코드를 작성하고 읽고 배우는 것이 좋은 연습이 될 것이다. 이상적이게도 각 언어들은 활성화된 커뮤니티를 가지고 있고 많은 코드를 생산해내며 운영되고 있다. 좋은 후보로는 C#, C++, Java, PHP, Python, Ruby 등이 있다.  \nC++ 면접관들이 면접자들에게 자주하는 질문 중에 \"1점부터 10점까지 자신의 C++ 지식이 몇점이라고 생각하는가?\" 라는 질문이 있다. 나는 이 질문을 싫어한다. 신은 9~10점으로 대답하는 사람을 돕는다. 비야네 스트롭스트룹(C++창시자)도 자신을 8로 평가한다고 대답한 적이 있기 때문이다. 언어는 복잡하고 방대하며 시간이 지남에 따라 많이 진화했다.  \n1. 복잡도를 공부하라.[이표를 참고하라](http://bigocheatsheet.com/)\n복잡도를 이해하면 어떻게 동작하는지 확신할 수 있다. 그리고 Dijkstra’s, Floyd-Warshall, Traveling Salesman, A*, bloom filter, breadth-first iterative search, binary search, k-way merge, bubble/selection/insertion sort, in-place quick sort, bucket/radix sort, closest pair 과 같은 일반적인 알고리즘을 구현해봐라. 다시말하지만 ABC. \n2. 바퀴를 재발명하라. 당신이 선택한 언어로 일반적인 자료구조를 구현하라. 라이브러리에 의존하지말고 vector (dynamic array), linked list, stack, queue, circular queue, hash map, set, priority queue, binary search tree 등을 구현하고 테스트하라. 빠르게 구현할 수 있어야 한다.\n3. 문제 풀기. 구글에서 인터뷰 문제를 검색하지마라. 어차피 기본적인 프로그래밍 개념으로 귀결된다. 다양한 유형의 문제에 대해 40시간 이상 고민하라. 탑코더가 좋은 참고자료다. [읽어보기](https://www.topcoder.com/community/competitive-programming/tutorials/) . 문제를 풀어봐라 recursive, pattern-matching, greedy, dynamic programming, and graph problems 등을 푸는 능력을 테스트하라. \n이것이 아마도 내가 구글에 고용된 첫번째 이유일 것이다. 나는 2주동안 TopCoder에 사로잡혀 보냈다. 그 후 나는 눈감고도 다익스트라 알고리즘을 구현할 수 있었다. 그리고 하늘아래 거의 모든 종류의 그래프 문제를 풀 수 있었다. 그것은 문제풀이의 반복이었다. 에릭슈미트의 말대로 \"반복은 배신하지 않는다.\"\n\n1. 코드를 쉽게 만들어라. 적어도 쉽게 보이도록 만들어라. 시간이 지나면서 나는 프로그래밍이 엔지니어가 되는 가장 간단한 방법이라는 것을 알게 되었다. 나는 종종 \"프로그래밍의 단순한 문제\"라는 문구를 사용한다. 왜냐하면 나는 인제니어가 되는 것이 대부분 코딩이 일어나기 전과 후라고 믿기 때문이다. 예를 들어, 코딩하려는 것을 설계하고 이미 코딩된 것을 확실히 하는 것은 전송이 가능하고 출시 준비가 되어 있다. 프로그래밍은 목적을 위한 수단일뿐이라는 것을 면접관이 이해하도록 하라. \n참고, 다른 사람들 앞에서 코딩하는 것은 부담스러울 수 있다. 화이트보딩과 페어프로그래밍을 모두 연습할 수 잇는 방법을 찾아보라. 구글은 기본적으로 화이트보드에서 코딩하고, 스퀘어는 IDE 에서 페어코딩하는 것이다. \n\n## General Tips\n\n비기술적인 조언들\n\n1. 니가 왜 거기 있는지 알아라. 만약 여러분이 어떤 회사에서 인터뷰를 하고 있는데 왜 그들이 존재하는지, 그들이 누구인지, 무엇을 하는지 완전히 이해하지 못한다면 좋은 평가를 받기 어려울 것이다. 대기업에서는 이 문제를 벗어날 수 있을지 모르지만, 작은 기업에서는 성공하지 못할 것이다.\n1. 열정적으로 행동하라. 무언가에 열정을 가져라. 프로그래밍일 수도 있지만,   여가시간에 컴파일러를 만드는 것을 즐기나? RC헬기를 만들고 조종하나? 그것은 별로 중요하지 않다. 왜냐하면 만약 당신이 그것에 대해 열정적이면, 당신은 그것을 흥미롭게 만들 수 있기 때문이다.\n1. 추측하지 마라. 잘 모르겠으면 질문해. 만약 질문을 받고 문제가 무엇인지 100% 확신하지 못한다면, 질문하라. 후보자가 어떤 길을 가고, 절대로 질문을 하지 않고 결국 잘못된 문제를 해결하는데 시간을 낭비하는 것을 본 적이 여러 번 있다.\n1. 웃어라. 흥분하고, 행복하고, 긍정적이어야 한다. 하지만 오버하지는 말고.  첫인상이 좋은 인상인지 확인하라. 웃음은 전염성이 있다, 나는 종종 기분이 안좋고 스트레스를 받으며 면접관으로 들어가서, 면접자의 미소를 보고 잊어버리기도 한다. \n\n","fields":{"slug":"/ABC/"},"frontmatter":{"title":"[번역] Always Be Coding","published":true}}},{"node":{"rawMarkdownBody":"\n\n웹알못의 블로그 구축 시작\n\ngithub에 블로그를 만들 수 있다고 해서 찾아보던 중\n\ngatsby라는 것을 발견\n\n마크업을 지원하고 플러그인도 많다고 함\n\n구글링을 통해 https://junhobaik.github.io/create-gatsby-blog/ 의 내용을 따라하고\n\n어찌어찌 블로그는 생성했고 Disqus도 붙이고 했으나\n\n포스팅을 작성할 때 마다 빌드하고 배포하는 번거로움이 (-_-)\n\n자동으로 배포하는 Netlify(https://app.netlify.com/) 라는 서비스가 있다고는 하는데 \n\n나름 세팅하고 deploy 를 돌려봤는데\n```\nFailed to get remote.origin.url (task must either be run in a git repository with a configured origin remote or must be configured with the \"repo\" option).\n```\n라는 에러 메세지가 뜬다. 아마도 추측컨데 빌드된 결과가 master 브랜치에 push 되어야 하는데 쓰기 권한이 없나보다. github 쪽 세팅에는  `Read and write access to checks, commit statuses, and pull requests` 라고 되어 있는데 뭐가 문제인지 모르겠다. \n\n\n아직 React 가 뭔지, node.js 가 뭔지 모르겠다. 웹프레임워크는 왜 이리 뭐가 많은지....\n\n-----\n\n(추가) \n\nhttps://www.netlify.com/docs/cli/\n\nnetlify 주소로는 deploy 가 됨\n\n-----\n\n(추가)\n\ngithub action 을 이용해서 자동 배포가 가능하다고 함 (아직 beta 라고 함)\n\n[GithubAction](https://github.com/features/actions) 신청한사람을 베타유저로 넣어준다고 하니 일단 신청하고 기다리는 중 \n\n\n## Reference\n\nhttps://blog.cometkim.kr/posts/%EB%82%98%EB%A7%8C%EC%9D%98-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0/0-%ED%94%8C%EB%9E%AB%ED%8F%BC-%EC%84%A0%EC%A0%95/\n\nhttps://anpigon.github.io/blog/kr/@anpigon/netlify-gatsby--1545785934223/\n\nhttps://junhobaik.github.io/create-gatsby-blog/\n\nhttps://medium.com/@changjoopark/travis-ci%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-github-pages-hexo-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%9E%90%EB%8F%99-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0-6a222a2013e6\n\n\n\n","fields":{"slug":"/git-gatsby-blog/"},"frontmatter":{"title":"Github 과 gatsby를 사용하여 블로그 만들기 (웹알못 주의))","published":true}}},{"node":{"rawMarkdownBody":"\n## posting test\n\n\n\n","fields":{"slug":"/2019_03-31-first-post/"},"frontmatter":{"title":"First Post, Test","published":true}}}]}},"pageContext":{}},"staticQueryHashes":["3649515864"]}