{"componentChunkName":"component---src-templates-blog-post-index-js","path":"/2020_03_27_cutting_rod/","result":{"data":{"site":{"siteMetadata":{"title":"My training box","author":"kklyoon"}},"markdownRemark":{"id":"c36ad2fc-d5be-5830-902a-6e82c06cce1b","html":"<p>원본 : <a href=\"https://www.geeksforgeeks.org/cutting-a-rod-dp-13/\">https://www.geeksforgeeks.org/cutting-a-rod-dp-13/</a></p>\n<h2>Cutting a Rod | DP-13</h2>\n<p>다음과 같이 단위 길이당 막대의 가격이 주어졌을 때 n 길이의 막대로 얻을 수 있는 최고가격을 구하라. 예를 들어 길이가 8인 막대가 주어졌을 때 최고 가격은 22이다. ( 길이가 2, 6인 막대로 자름)</p>\n<table>\n<thead>\n<tr>\n<th>length</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>price</td>\n<td>1</td>\n<td>5</td>\n<td>8</td>\n<td>9</td>\n<td>10</td>\n<td>17</td>\n<td>17</td>\n<td>20</td>\n</tr>\n</tbody>\n</table>\n<p>단순한 방법으로 접근하면 길이의 모든 조합을 찾아서 가장 높은 가격을 계산한다. 하지만 complexity 가 많이 걸림. DP 방식으로 어떻게 풀 수 있는지 알아보자</p>\n<p><strong>1) 효율적인 구조:</strong> </br></p>\n<p>각각 다른 위치에서 통나무를 자르고 나서 가격을 계산한뒤 최고 값을 구할 수 있다. 이를 재귀함수로 구현할 수 있다.</p>\n<p>cutRod(n) 를 길이가 n 일 때 최고 값이라고 가정하면 점화식은 다음과 같다. </p>\n<p>cutRod(n) = max(price[i] + cutRod(n-i-1)) for all i in {0, 1 .. n-1} <br>\nmax(i길이의 값 + cutRod(n-i-1)) : price[i] 의 값과 나머지 길이의 가격의 최대 값의 합</p>\n<p><strong>2) 중복문제</strong></br></p>\n<p>다음과 같이 간단한 재귀함수를 구현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\">\n      <pre class=\"language-c++\"><code class=\"language-c++\">int cutRod(int price[], int n) \n{ \n   if (n &lt;= 0) \n     return 0; \n   int max_val = 0; \n  \n   // Recursively cut the rod in different pieces and compare different  \n   // configurations \n   for (int i = 0; i&lt;n; i++) \n         max_val = max(max_val, price[i] + cutRod(price, n-i-1)); \n  \n   return max_val; \n} </code></pre>\n      </div>\n<p>막대의 길이가 4라고 가정하면 다음과 같은 재귀트리가 생성된다. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\">\n      <pre class=\"language-text\"><code class=\"language-text\">cR() ---&gt; cutRod() \n\n                             cR(4)\n                  /        /           \n                 /        /              \n             cR(3)       cR(2)     cR(1)   cR(0)\n            /  |         /         |\n           /   |        /          |  \n      cR(2) cR(1) cR(0) cR(1) cR(0) cR(0)\n     /        |          |\n    /         |          |   \n  cR(1) cR(0) cR(0)      cR(0)\n   /\n /\nCR(0)</code></pre>\n      </div>\n<p>위의 트리를 참고하면 cR(2) 같은 경우 두번 계산되게 된다. 트리의 depth 가 깊으면 깊을수록 이런 중복된 계산이 많아질 것이다. 따라서 이렇게 계산된 값들은 미리 저장해두는 것이 좋다. </p>\n<div class=\"gatsby-highlight\" data-language=\"c++\">\n      <pre class=\"language-c++\"><code class=\"language-c++\">int cutRod(int price[], int n) \n{ \n   int val[n+1]; \n   val[0] = 0; \n   int i, j; \n  \n   // Build the table val[] in bottom up manner and return the last entry \n   // from the table \n   for (i = 1; i&lt;=n; i++) \n   { \n       int max_val = 0; \n       for (j = 0; j &lt; i; j++) \n         max_val = max(max_val, price[j] + val[i-j-1]); \n       val[i] = max_val; \n   } \n  \n   return val[n]; \n} </code></pre>\n      </div>\n<p>val[i] 는 i 길이 일때 최대값, 길이는 1부터 시작 <br></p>\n<p>Time Complexity 는 O(n<sup>2</sup>)로 첫번째 방법의 worst case 보다 낫다. </p>\n<p>재귀함수 구현은 다음과 같음</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\">\n      <pre class=\"language-c++\"><code class=\"language-c++\">int cutting_rod_recurv(int price[], int n, int cut)\n{\n    if( cut == n-1 )\n    {\n        return price[n-1];\n    }\n\n    return std::max( (price[cut] + price[n-1-cut-1]), cutting_rod_recurv(price, n, cut+1) );\n}</code></pre>\n      </div>","excerpt":"원본 : https://www.geeksforgeeks.org/cutting-a-rod-dp-13/ Cutting a Rod | DP-13 다음과 같이 단위 길이당 막대의 가격이 주어졌을 때 n…","frontmatter":{"title":"[Algorithm] 막대 자르기","date":"2020-03-27","tags":["programming","algorithm","알고리즘","막대자르기"],"keywords":["My training box"]}}},"pageContext":{"slug":"/2020_03_27_cutting_rod/","previous":{"fields":{"slug":"/2020_03_27_github_action/"},"frontmatter":{"title":"github action 사용하기 (gatsby 자동 배포)","tags":["git","github","githubaction","action","gatsby","npm"],"published":true}},"next":{"fields":{"slug":"/2020_03_28_sorting_012/"},"frontmatter":{"title":"[Algorithm] 0, 1, 2로 이루어진 배열 정렬하기","tags":["algorithm","sort","알고리즘","C++","kotlin"],"published":true}}}},"staticQueryHashes":["3649515864"]}