{"componentChunkName":"component---src-templates-blog-post-index-js","path":"/2020_04_06_between-two-sets/","result":{"data":{"site":{"siteMetadata":{"title":"My training box","author":"kklyoon"}},"markdownRemark":{"id":"84c09dfc-6b25-5fb6-b599-7d845cf9f26e","html":"<p>원문 : <a href=\"https://www.hackerrank.com/challenges/between-two-sets/problem\">https://www.hackerrank.com/challenges/between-two-sets/problem</a></p>\n<p>You will be given two arrays of integers and asked to determine all integers that satisfy the following two conditions:</p>\n<p>The elements of the first array are all factors of the integer being considered\nThe integer being considered is a factor of all elements of the second array\nThese numbers are referred to as being between the two arrays. You must determine how many such numbers exist.</p>\n<p>Function Description</p>\n<p>Complete the getTotalX function in the editor below. It should return the number of integers that are betwen the sets.</p>\n<p>getTotalX has the following parameter(s):</p>\n<p>a: an array of integers\nb: an array of integers</p>\n<p>요약하자면 배열 a의 공배수의 집합\n배열 b의 공약수의 집합\n이 둘의 공집합의 원소의 갯수를 출력하는 문제 (번역이 잘 안되서 한참을 다시 읽어봄)</p>\n<p>배열을 따로 만들어서 해결해야하나 라는 고민이 먼저 들지만 포럼에서 결론을 내놓았다.</p>\n<p>결과값에서 요구하는게 아니라면 다르게 접근할수도 있겠구나 생각함</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\">\n      <pre class=\"language-c++\"><code class=\"language-c++\">// 최대 공약수\n int gcd(int a, int b){\n     while(b!=0){\n         int r = a%b;\n         a = b;\n         b = r;\n     }\n     return a;\n }\n// 배열에서의 최대 공약수\n int gcd(vector&lt;int&gt; input){\n     int result = input[0];\n     for(int i = 1 ; i &lt; input.size(); i++){\n         result = gcd(result, input[i]);\n     }\n     return result;\n }\n// 최소 공배수\n int lcm(int a, int b){\n     return a*b/ gcd(a,b);\n }\n // 배열에서의 최소 공배수\n int lcm(vector&lt;int&gt; input){\n     int result = input[0];\n     for(int i = 1 ; i &lt; input.size(); i++){\n         result = lcm(result, input[i]);\n     }\n     return result;\n }\n\nint getTotalX(vector&lt;int&gt; a, vector&lt;int&gt; b) {\n    int f = lcm(a);     // 배열 a의 최소 공배수를 구한다.\n    int l = gcd(b);     // 배열 b의 최대 공약수를 구한다.\n    int count = 0;\n    for(int i = f, j = 2; i &lt;= l; i= f*j, j++){   // 반복문 시작에 배열 a의 최소 공배수를 넣고 최소 공배수를 *2, *3 식으로 곱하면서 배열 b의 최대 공약수에 도달할때까지 반복\n        if(l%i==0) count++;       // 반복하는 동안 배열 b의 최대 공약수를 나눌 수 있으면 카운트\n    }\n    return count;\n}</code></pre>\n      </div>","excerpt":"원문 : https://www.hackerrank.com/challenges/between-two-sets/problem You will be given two arrays of integers and asked to determine all…","frontmatter":{"title":"[Algorithm][hackerrank] Between Two Sets","date":"2020-04-06","tags":["알고리즘","algorithm","hackerrank"],"keywords":["My training box"]}}},"pageContext":{"slug":"/2020_04_06_between-two-sets/","previous":{"fields":{"slug":"/2020_04_04_longest-substring-without-repeating-characters/"},"frontmatter":{"title":"[Algorithm][LeetCode] find the length of the longest substring without repeating characters","tags":["알고리즘","algorithm"],"published":true}},"next":{"fields":{"slug":"/2020_04_06_Array Manipulation/"},"frontmatter":{"title":"[Algorithm][hackerrank] Array Manipulation","tags":["알고리즘","algorithm","hackerrank"],"published":true}}}},"staticQueryHashes":["3649515864"]}